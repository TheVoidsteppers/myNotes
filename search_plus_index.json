{"./":{"url":"./","title":"前言","keywords":"","body":"我的学习笔记 本项目使用 markdown 书写，gitbook 生成 gitbook 相关 安装 npm i 本地运行 npm run dev 发布 npm run prd "},"HTML/":{"url":"HTML/","title":"HTML","keywords":"","body":"HTML HTML 基础 "},"HTML/base.html":{"url":"HTML/base.html","title":"HTML 基础","keywords":"","body":"html 基础 ~ 水平线 换行 字体 加粗 斜体 删除线 下划线 src=\"url或路径\" 图片地址 alt=\"文字\" 图片不存在显示 tittle=\"文字\" 鼠标悬停时显示 width/heigth=\"数值\" 图片像素 border=\"数字\" 边框大小 anchor锚，链接 href=\"url\" 外部：http：// 、 本地：文件名.html 、 临时地址：# target=\"目标窗口弹出方式\" _self 、 __blank(新窗口) 锚点定位 页内跳转 文本 文本 邮箱 表单 "},"CSS/":{"url":"CSS/","title":"CSS","keywords":"","body":"CSS 本章主要介绍两个方面的内容： CSS 基础 CSS 样例 "},"CSS/base.html":{"url":"CSS/base.html","title":"CSS 基础","keywords":"","body":"box-shadow box-shadow: h-shadow v-shadow blur spread color inset; 参数详解： h-shadow: 阴影的水平偏移量。 v-shadow: 阴影的垂直偏移量。 blur: 模糊距离(就是渐变的距离，设为0就没有渐变)。 spread: 投影的尺寸，通过这个控制“影分身”的大小。 color: 投影颜色，通过这个实现后方的乌云。 inset: 改为内阴影。这里用不到。 选择器 id选择器 类名选择器 伪类选择器 /* 找到P元素，通过P找到父元素，通过父元素找子元素当中类型为P的，然再去找第几个。 p:first-of-type p:last-of-type p:nth-of-type(n) p:nth-last-of-type(n) å¦‚æžœä½¿ç”¨çš„æ˜¯child; p:first-child 找到P元素,通过P找到父元素，通过父元素找所有的子元素，找第一个元素，匹配判断类型(如果不是无效选择器) */ clip-path 可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏 /* Keyword values */ clip-path: none; /* values */ clip-path: url(resources.svg#c1); /* values */ /* 如果同 一起声明，它将为基本形状提供相应的参考框盒。通过自定义，它将利用确定的盒子边缘包括任何形状边角（比如说，被 border-radius 定义的剪切路径）*/ clip-path: margin-box; clip-path: border-box; clip-path: padding-box; clip-path: content-box; clip-path: fill-box; clip-path: stroke-box; clip-path: view-box; /* values */ clip-path: inset(100px 50px); /*矩形 ( {1,4} [ round ]? ) 上 右 下 左 */ clip-path: circle(50px at 0 100px); /*椭圆 ( [ ]? [ at ]? )*/ clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); /*多边形 ( ? , [ ]# )*/ clip-path: path('M0.5,1 C0.5,1,0,0.7,0,0.3 A0.25,0.25,1,1,1,0.5,0.3 A0.25,0.25,1,1,1,1,0.3 C1,0.7,0.5,1,0.5,1 Z'); /* Box and shape values combined */ clip-path: padding-box circle(50px at 0 100px); /* Global values */ clip-path: inherit; clip-path: initial; clip-path: unset; filter 将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染 /* URL to SVG filter */ /*接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素*/ filter: url(\"filters.svg#filter-id\"); /*==============================================*/ /* values */ filter: blur(5px);/*( )*/ /*给图像设置高斯模糊。“length”一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起，所以值越大越模糊；则默认是0；*/ filter: brightness(0.4);/*( )*/ /*给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。默认是1。*/ filter: contrast(200%);/*( [ ] )*/ /*调整图像的对比度。0%的话，图像会全黑。100%，图像不变。可以超过100%，意味着会运用更低的对比。默认是1。*/ filter: drop-shadow(16px 16px 20px blue);/*( {2,3} ? )*/ /*给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 函数接受（在CSS3背景中定义）类型的值，除了“inset”关键字是不允许的。该函数与已有的 box-shadow 属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速。*/ filter: grayscale(50%);/*( )*/ /*将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。值默认是0。*/ filter: hue-rotate(90deg);/*( )*/ /*给图像应用色相旋转。“angle”一值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。*/ filter: invert(75%);/*( )*/ /*反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 值默认是0。*/ filter: opacity(25%);/*( )*/ /*转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。 值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。*/ filter: saturate(30%);/*( )*/ /*转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。值默认是1。*/ filter: sepia(60%);/*( )*/ /*将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。值默认是0。*/ /*==============================================*/ /* Multiple filters */ filter: contrast(175%) brightness(3%); /*==============================================*/ /* Global values */ filter: inherit; filter: initial; filter: unset; "},"CSS/demos.html":{"url":"CSS/demos.html","title":"CSS 样例","keywords":"","body":"CSS3 的 animation 制作的动画效果的 CSS 集合：https://daneden.github.io/animate.css/ 布局 flex 布局 .box { display: flex; display: inline-flex; /* 行内元素 */ display: -webkit-flex; /* Safari */ } 文本 自动换行 /*一行*/ word-wrap: break-word; word-break: break-all; /* 两行 */ overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; /*超出文字 省略号替代*/ overflow: hidden; text-overflow: ellipsis; white-space: nowrap; 文字渐变色 background: linear-gradient(to right, #ff338e, #f83e3e); -webkit-background-clip: text; color: transparent; 文本环绕 .box1 { float: left; width: 100px; height: 100px; background: pink; } .box2 { /*让这个元素绝对绝缘 bfc*/ /*不让其他浮动元素影响自己*/ /*不让自己的浮动去影响别的元素*/ overflow: hidden; } 内容内容内容内容内容内容内容内容内容内容内容内容 去掉文本选中效果 -webkit-touch-callout: none; /* iOS Safari */ -webkit-user-select: none; /* Chrome/Safari/Opera */ -khtml-user-select: none; /* Konqueror */ -moz-user-select: none; /* Firefox */ -ms-user-select: none; /* Internet Explorer/Edge */ user-select: none; /* Non-prefixed version, currently not supported by any browser */ 背景 背景图片 --- 显示位置、裁剪 /*让背景从内容开始平铺*/ background-origin: content-box; /*没有做背景裁剪 背景图默认就是从边框显示*/ /*默认的就是 border-box 边框以外被裁剪掉 padding-box 内边距以外被裁剪掉 content-box 内容以外被裁剪掉 */ background-clip: content-box; 边框 三角形 div::before { width: 0; height: 0; content: \"\"; position: absolute; left: 85px; top: -10px; border-left: solid 10px transparent; border-bottom: solid 10px rgba(255, 255, 255, 0.9); border-right: solid 10px transparent; } 其他 去掉图片下间隙 /* 图片默认是文字，以基线对齐 */ body { /*font-size: 0px;*/ } img { /*display: block;*/ vertical-align: middle; } 模仿 placeholder .title:empty:not(:focus):before { content: attr(data-placeholder); } 去掉已设置的样式 initial | inherit; 滚动条美化 /*滚动条美化*/ ::-webkit-scrollbar-track-piece { /*滚动条凹槽的颜色，还可以设置边框属性*/ background-color: #f8f8f8; } ::-webkit-scrollbar { /*滚动条的宽度*/ width: 9px; height: 9px; } ::-webkit-scrollbar-thumb { /*滚动条的设置*/ background-color: #dddddd; background-clip: padding-box; min-height: 28px; } ::-webkit-scrollbar-thumb:hover { background-color: #bbb; } /*滚动条美化 end*/ 添加字体 /*自定义字体图标*/ /*1.通过@font-face定义自己的字体*/ @font-face { /*2.申明自己的字体名称*/ font-family: \"wjs\"; /*3.引入字体文件（约束某一段字符代码什么图案）*/ src: url(../fonts/MiFie-Web-Font.svg) format(\"svg\"), url(../fonts/MiFie-Web-Font.eot) format(\"embedded-opentype\"), url(../fonts/MiFie-Web-Font.ttf) format(\"truetype\"), url(../fonts/MiFie-Web-Font.woff) format(\"woff\"); } /*4.怎么使用维护性更好*/ .wjs_icon { font-family: wjs; } 媒体查询 /*使用媒体查询能针对不同屏幕区间设置不同的布局和样式*/ /*怎么使用媒体查询：关于媒体查询 @media */ /*语法： @media screen and (max-width: 768px) and (min-width: 320px){属性样式}*/ @media screen and (max-width: 768px) { /*1. 在超小屏设备的时候 768px以下 当前容器的宽度100% 背景蓝色*/ .container { width: 100%; background: blue; } } "},"JavaScript/":{"url":"JavaScript/","title":"JavaScript","keywords":"","body":"JavaScript 本章主要介绍两个方面的内容： JavaScript 基础 JavaScript 高级 JavaScript 进阶 EcmaScript6 jQuery JavaScript 样例 "},"JavaScript/base.html":{"url":"JavaScript/base.html","title":"JavaScript 基础","keywords":"","body":"js的介绍 布兰登·艾奇 js发明人 js是什么： js 是一门脚本语言； js 是一门解释性语言； js 是一门动态类型语言； js 是一门基于对象语言； js 的作用： 最初作用：解决用户和浏览器之间的交互问题 现在用于：1.网页特效 2.服务端开发（Node.js） 3.命令行工具（Node.js） 4. 桌面程序（Electron） 5.App（Cordova） 6. 控制硬件--物联网（Ruff）7.游戏开发（cocos2d-js） js和html、css的区别： Html：标记语言，展示数据，提供网页的结构，提供网页的内容 Css：美化页面 JS： 用户和浏览器交互 ，控制网页内容，给网页增加动态效果 js的代码可以在哪三个地方写: 1、在html的文件中，script的标签写js代码 2、js代码可以在html的标签中写 3、在js文件中可以写js代码，但需要在html的页面中引入 ，script的标签中src=\"js的路径\" js的注意问题： 1、在一对script的标签中有错误的js代码，那么该错误代码后面的js代码不会执行 2、如果第一对的script标签中有错误，不会影响到后面的script标签中的js代码执行 3、script的标签中可以写 type=\"text/javascript\"这是标准写法 或者写language=\"Javascript\" 都可以但是，目前在我们的html页面中，type和language都可以省略，html遵循h5的标准 4、有可能出现script标签中同时出现type和language的写法 5、script标签在页面中可以出现多对 6、script标签一般是放在body的标签的最后，有时候会在head标签中 7、如果script标签是引入外部js文件的作用，那么这对标签中不要写任何js代码，应重新写一对script标签 变量 操作的数据都是在内存中操作 js中存储数据使用变量的方式（名字，值--->数据） js声明变量都用var-----> 存储数据，数据应该有对应的数据类型，字符串类型的值都用成对的双引号或单引号 变量的作用： 存储数据或操作数据 变量声明（有var 有变量名字， 没有赋值） var number,x,y; 变量初始化（有var 有变量名字，有赋值） var number=10; （代码的规范）js变量声明都用var ，js中的每一行代码结束都应有分号；，js中区分大小写，js的字符串可以使用单引号|双引号。 变量名的注意问题： 变量名的命名规范，要遵循驼峰命名法 1、变量的名字要有意义， 2、变量名一般以字母，$，_开头，中间或者后面可以用$， 字母，数字 3、变量名一般都是小写 4、变量名如果是多个单词，第一个单词的首字母是小写的，后面的所有单词的首字母都是大写的，这种命名方式称为：驼峰命名法 var bigNumber=10； 5、不能使用关键字 变量的交换方式： 1、使用第三方的变量进行交换， var num1=10; var num2=20; var temp; temp=num1; num1=num2; num2=temp; 2、一般适用于数字交换 var num1=10; var num2=20; num1=num1+num2; num2=num1-num2; num1=num1-num2; 3、扩展（无需了解） var num1=10; var num2=20; num1=num1^num2; num2=num1^num2; num1=num1^num2; 注释： 单行注释：// 一般用于单行代码的上方; 多行注释：/**/ 一般用于函数或整段代码的上方 数字类型 js中的 原始数据类型： number：数字类型（整数和小数） string：字符串类型（用单引号或双引号括起来） boolean：布尔类型（true（真1），false（假0）） null：空类型，值为null，一个对象指向为空，赋值为null时，是赋值到指向为空的对象。 undefined：未定义，值为undefined（变量声明了未赋值，函数没有明确的返回值），undefined和一个数字进行计算，得到NaN（not a number） object：对象 获取数据类型： typeof 变量名 typeof(变量名) 进制表示： var num=10;//十进制 var num1=012;//八进制 var num2=0x123;//十六进制 数字类型的范围： console.log(Number.MAX_VALUE);//最大值（再往上加显示的还是该值） console.log(Number.MIN_VALUE);//最小值 Infinity 无穷大 -Infinity 无穷小 注意： 1、不要用小数去验证小数，在内存存储的小数精度有限0.1 + 0.2 != 0.3 2、不要用NAN去验证NAN，NAN（not a num）与任何值都不相等，包括它本身，可以用isNAN(变量名)验证 字符串类型 字符串可以用成对的单引号或双引号括起来 获取字符串的长度：变量名.length js中的转义符：/b 换行 /t制表符。。。 字符串的拼接：str1+str2 ，注意只要有一个是字符串，其他的是数字，结果也是拼接 var str1=\"10\"; var str2=5; console.log(str1*str2); /* *结果是50，除+外，js会把与数字相运算的字符串转换成数字，这种方式叫隐式转换 */ 布尔类型 true(1)和false(0)，区分大小写 undefine和null undefined声明未赋值 null要设置必须手动设置 类型转换 其他类型转数字类型： 1、parseInt();//转整数 console.log(parseInt(\"10\"));//10 console.log(parseInt(\"10asda\"));//10 console.log(parseInt(\"a10\"));//NaN console.log(parseInt(\"1asd0\"));//1 console.log(parseInt(\"10.98\"));//10 console.log(parseInt(\"10.98asda\"));//10 2、parseFloat();//转小数 console.log(parseFloat(\"10\"));//10 console.log(parseFloat(\"10asda\"));//10 console.log(parseFloat(\"a10\"));//NaN console.log(parseFloat(\"1asd0\"));//1 console.log(parseFloat(\"10.98\"));//10.98 console.log(parseFloat(\"10.98asda\"));//10.98 3、Number();//转数字 console.log(Number(\"10\"));//10 console.log(Number(\"10asda\"));//NaN console.log(Number(\"a10\"));//NaN console.log(Number(\"1asd0\"));//NaN console.log(Number(\"10.98\"));//10.98 console.log(Number(\"10.98asda\"));//NaN 其他类型转字符串类型： 1、.toString(); var num=10; console.log(num.toString());//字符串类型 //如果变量有意义，调用.toString()转换 2、String(); var num=10; console.log(String(num)); //如果变量没有意义（undefined,null），调用Strig()转换 其他类型转布尔类型： 1、Boolean(值)； console.log(Boolean(1));//true console.log(Boolean(0));//false console.log(Boolean(11));//true console.log(Boolean(-1));//true console.log(Boolean(\"哈哈\"));//true console.log(Boolean(\"\"));//false console.log(Boolean(\"null\"));//false console.log(Boolean(\"undefined\"));//false 运算符 算数运算符： 有： + - / % 一元运算符： 这个运算符只需要一个操作数就可以运算的符号：++ --，如果不参与运算，++/--在前在后没差别。 1、++ ： var num=10; var sum=num++ +10; console.log(sum);//20 console.log(num);//11 //如果++在后面：如上式参与运算，先参与运算，运算结束后自身再加1。在后后加 var num=10; var sum=++num+10; console.log(sum);//21 console.log(num);//11 //如果++在前面：如上式参与运算，先自身加1，再参与运算。在前先加 var i=1; var j=i++ + i++;//=>1 + 2++=3 console.log(j);//3 console.log(i);//3 //++对自身的加是在整个运算中的，而不是等运算结束后在对自身加 2、--： var num=10; var sum=num-- +10; console.log(sum);//20 console.log(num);//9 //如果--在后面：如上式参与运算，先参与运算，运算结束后自身再减1 var num=10; var sum=--num+10; console.log(sum);//19 console.log(num);//9 //如果--在前面：如上式参与运算，先自身减1，再参与运算 二元运算符： 三元运算符： 转到三元表达式语句 复合运算符： += -= *= /= %= 关系运算符： >= 逻辑运算符： &&---逻辑与 ||---逻辑或 !---逻辑非 运算符的优先级： 1.（）最高 2.一元运算符 ++ -- ！ 3.算数运算符 * / + - 4.关系运算符 > >= 字面量：把一个值直接赋值给一个变量 流程控制 代码的执行过程 流程控制的方式 1、顺序结构： 从上到下，从左到右执行的顺序 2、分支结构： if语句： 主要是判断 /* 语法： if(表达式){ 代码块 } 执行过程：先判断表达式的结果是true还是false，如果是true，则执行代码块 */ if(8>6){ console.log(8); }//8 if-else语句： 两个分支，只能执行一个分支 /* if(表达式){ 代码1 }else{ 代码2 } 执行过程：如果表达式的结果是true，则执行代码1，否则执行代码2 */ var num1=10; var num2=20; if(num1>num2){ console.log(num1); }else{ console.log(num2); } if-else if-else if...语句： 最终也是执行一个；与switch-case相比，一般是对范围的判断 /* 语法： if(表达式1){ 代码1 }else if(表达式2){ 代码2 }else if(代码3){ 代码3 }else{ 代码4 } 执行过程：先判断表达式1的结果，如果为true，则执行代码1；如果为false，判断表达式2，如果为true，则执行代码2；。。。 */ var score=Number(prompt(\"请您输入成绩\")); if(!isNaN(score)){//如果是数字 if(score>90&&score80){ console.log(\"B级\"); }else if(score>70){ console.log(\"C级\"); }else if(score>=60){ console.log(\"D级\"); }else{ console.log(\"E级\"); } }else{ console.log(\"输入有误\"); } switch-case语句： 分支语句，多分支语句；与if-else if else if...相比，一般是对具体值得判断 /* 语法： switch(表达式){ case 值1: 代码1; break; case 值2: 代码2; break; case 值3: 代码3; break; case 值4: 代码4; break; ... default: 代码5; break;//可以省略 } 执行过程：获取表达式的值，和值1比较，如果一样，则执行代码1，遇到break则跳出整个语句，后面的代码不执行； ... */ var level=\"c\"; switch(level){ case \"a\":console.log(\"90~100\");break; case \"b\":console.log(\"80~90\");break; case \"c\":console.log(\"70~80\");break; case \"d\":console.log(\"60~70\");break; case \"e\":console.log(\"0~60\");break; }//70~80 注意的问题： default后面的break是可以省略的 default也是可以省略的 switch-case 语句中和case后面的值比较的时候是严格模式=== break是可以省略的，但是后面的代码会执行直到遇到break 表达式判断与case 的值一样后，如果没有break，后面的case后的代码会继续执行 三元表达式语句： /* 运算符号：？ ： 语法： var 变量=表达式1？表达式2:表达式3; 执行过程：表达式1的结果是true则执行表达式2，然后把结果给变量，如果表达式1的结果是false，则执行表达式3，把结果给变量。 */ var x=10; var y=20; var result=x>y?x:y; console.log(result);//20 3、循环结构 while循环： 特点：先判断后循环，有可能一次循环体都不执行。 /* while循环语法： 计数器 var 变量=0; while（循环的条件）{ 循环体; 计数器++; } 执行过程：先判断循环的条件，如果是true，则执行循环体，计数器加1；再判断循环的条件，重复上述步骤；直到循环的条件为false。 */ var i=0; while(i do-while循环： 特点：先执行后判断，循环体至少执行一次。 /* do-while循环语法： do{ 循环体; 计数器++； }while(条件); 执行过程：先执行一次循环体，然后判断条件是否成立，为true，则继续执行；重复直到判断条件为false。 */ var i=1; var sum=0; do{ if(i%3==0){ sum+=i; } i++; }while(i for循环： /* for循环语法： for(表达式1;表达式2;表达式3){ 循环体; } 执行过程：先执行表达式1，然后判断表达式2，为true，则执行循环体，执行表达式3，再判断表达式2，重复以上步骤，直到表达式2为false。 */ for(var i=0;i 后期还有for-in循环： 关键字 break： 如果在循环中使用，遇到break，则立即跳出当前所在的循环。 continue： 在循环中，遇到continue；直接开始下一次循环。 数组 一组有序的数据。 数组的作用： 可以一次性存储多个数据。 数组的语法： 1、通过构造函数创建数组: var 数组名=new Array(); var array=new Array();//定义了一个空数组。 //数组的名字如果直接输出，那么直接就把数组中的数据显示出来；如果没有数据，就看不到数据。 var array=new Array(5);//长度为5 var array=new Array(10,20,30,40,50);//长度为5，数据为[10,20,30,40,50] 2、通过字面量的方式： var 数组名=[];//空数组 var array=[]; var array=[10];//值为10，长度为1 小结： 无论是构造函数的方式还是字面量的方式，定义了有长度的数组，默认值是undefined； 数组元素：数组中每个数据都可以叫数组的元素； 数组长度：就是数组的元素的个数； 数组索引（下标）：用来存储或访问数组中的数据的，索引从0开始； 如何设置数组中某个位置的值： 数组名[下标]=值； array[3]=100; 如何获取数组中某个位置的值： var result=数组名[下标]； console.log(result)； 数组存储的类型可以不一样： var arr=[10,\"hello world\",true,null,undefined,new Object()] 数组的长度可以改变： var arr=[]; arr[1]=10; console.log(arr.length); //去掉数组中的0，并放到一个新数组中去 var arr=[10,20,0,30,0,40,50,0]; newArr=[]; for(i=0;iarr[j+1]){ var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=arr[j]; } } } console.log(arr); 函数 把一坨重复的代码封装，在需要的时候直接调用 函数的作用： 代码的重用 函数的语法： //函数的定义 function 函数名(){ 函数体; } //函数的调用 函数名(); 函数的参数： 在函数定义的时候，函数名字后面的小括号的变量就是参数，目的是在函数调用时，对用户传进来的值进行操作。 形参：函数在定义时小括号里的变量叫形参 实参：函数在调用时小括号里传入的值叫实参，实参可以是变量也可以是值 形参的个数和实参的个数可以不一致 函数的返回值： 函数的返回值：在函数内部有return关键字，并且在关键字后面有内容，这个内容被返回了 当函数调用之后，需要这个函数的返回值，可以定义变量接收 如果一个函数没有返回值，但在调用的时候定义变量接收返回值，那么结果就是undefined；有return但没有明确的返回值，结果也一样 没有明确返回值：无return或者return 后为空 return下面的代码是不会执行的 return在函数的循环中相当于break 函数里面可以调用其他函数 function sum(x,y){//形参 var sum=x+y; return sum； } var num1=parseInt(prompt(\"请输入第一个数：\")); var num2=parseInt(prompt(\"请输入第二个数：\")); var result=sum(num1,num2);//实参 console.log(result); console.log(sum);//显示sum函数的代码 arguments对象： 定义一个函数，如果不确定用户是否传入参数或不确定参数的个数 //定义 function f1(){ //arguments相当于一个数组，但是是伪数组 var sum=0; for(var i=0;i 函数的其他定义方式： 命名函数：函数有名字 匿名函数：函数没有名字，匿名函数不能直接调用 函数表达式： 把一个函数赋值给一个变量，形成函数表达式 变量存储的是一个函数，可以通过加\"( )\"直接调用 /* var 变量=匿名函数； var f1=function (){ 函数体 }; */ var f4=function (){ console.log(\"hello world\"); };//必须加;号，此时是赋值操作!!!!!!!!!!!!!!! f4(); //两个方式的对比 //函数声明================================ function f1(){ console.log(\"hello world\"); } f1();//hello,函数重名了，不管在哪调用都会是后面新定义的函数(http://example.com/\"doubleName\") function f1(){ console.log(\"hello\"); } f1();//hello //函数表达式============================= var f2=function (){ console.log(\"hello world\"); }; f2();//hello world,相当于变量的重新赋值，后面的不会影响前面的 f2=function (){ console.log(\"hello\"); }; f2();//hello //总结：函数表达式会比函数声明更安全一些 函数自调用： 没有名字，声明的同时，直接调用 一次性的---都是匿名函数，不会有重复 (function (){ console.log(\"hello world\"); })(); 函数数据类型： 是function类型 function f1(){ console.log(\"hello world\"); } console.log(typeof f1); 回调函数： 函数可以作为参数使用，如果一个函数作为参数，这个函数就叫回调函数 只要看到一个函数作为参数使用，它就是回调函数 function f1(fn){ fn();//fn是一个函数 } function f2(){ console.log(\"hello world\"); } f1(f2);//hello world 函数作为返回值使用 function f1(){ return function (){ console.log(\"this is a function\"); } } var f2=f1();//此时f2内存储的是一个匿名函数 作用域 全局变量： 声明的变量是使用var声明的，可以在页面的任何位置使用 除了函数内部定义的，其他位置定义的变量都是全局变量 全局变量，如果页面不关闭，内存就不会释放，消耗内存！ 局部变量: 在函数内部定义的变量，外面不能使用 全局作用域： 全局变量的使用范围 局部作用域： 局部变量的使用范围 块级作用域： 一对大括号就是一块，在块内定义的变量，只能在这个区域中使用； 但是在js中，没有块级作用域，在块外也能使用。//函数除外 扩展： 隐式全局变量： 声明的变量不使用var function f1() { number =100;//此时是隐式全局变量，可以被外部引用 } f1(); console.log(number);//100 //全局变量是不能被删除的，隐式全局变量可以被删除 var num1=10; num2=20; delete num1;//删除了num1 delete num2; console.log(typeof num1);//number console.log(typeof num2);//undefined，此时要用typeof，否则直接输num2会报错 //总结：声明变量使用var是不会被删除的，没有var的可以被删除 //变量的重新赋值不是隐式全局变量！！！！！！！！！！ 作用域链： var num=10;//0级作用域：在script标签下，函数外定义的变量 function f1() { var num=20;//1级作用域 function f2(){ var num=30;//2级作用域 function f3(){ var num=50;//3级作用域 console.log(num);//50；若3级作用域没重新赋值，则往上找直到0级作用域 } f3(); } f2(); } //变量的值：关系找最亲的，往上找，直到0级作用域 预解析 在执行代码之前，提前解析代码 把变量的声明/函数的声明提前了--------提前到当前（函数）所在的作用域的最上面！！！！ console.log(num);//undefined var num=10; /*相当于 var num; console.log(num); num=10; 可以解释前面的 */ //高级例子 f1();//undefined,===================>|var num=20; var num=20;// |function f1(){ function f1(){// | var num; console.log(num);// | console.log(num); var num=10;// | num=10; }// |} // |f1(); f1();//undefined,===================>|var num; var num=20;// |function f1(){ function f1(){// | console.log(num); console.log(num);// |} }// |f1(); // |num=20; //总结：需提前解析？-->按执行顺序提前到当前域的前面，即变量使用之前 f1(); console.log(c);//9 console.log(b);//9 console.log(a);//报错 function f1(){ var a=b=c=9; cosole.log(a);//9 cosole.log(b);//9 cosole.log(c);//9 } /*等价于下面的 function f1(){ var a; a=9;//局部变量 b=9；//隐式全局变量 c=9;//隐式全局变量 cosole.log(a);//9 cosole.log(b);//9 cosole.log(c);//9 }*/ f1(); console.log(c);//9 console.log(b);//9 console.log(a);//报错，因为除了a不是全局变量，b、c都是 //易错点 f1();//报错 var f1=function (){ console.log(a); var a=10; } /* var f1; f1();//不能调用！ */ 函数表达式 小结： 预解析中，变量的提升只会在当前的在作用域中提升，提前到当前的作用域的最上面 函数中的变量只会提前到函数的作用域的前面，不会超出函数 预解析会分段（多对的script标签中函数重名，互不影响） 变量的声明提前，不会提升赋值；函数的声明提前，不会提升调用 变量名和函数名重名了，且有预解析时，变量名提升在最上面 编程思想 面向过程： 每件事的具体过程都要知道，注重过程 面向对象： 根据需求找对象，所有的事都由对象来做，注重结果 面向对象的特性：封装，继承，多态（抽象性） js不是面向对象的语言，但是可以模拟面向对象的思想 js是一门基于对象的语言 有属性和方法，特指的某个事物 一组无序属性的集合的键值对，属性的值可以是任意的类型 对象 创建对象的三种方式： 1、调用系统的构造函数创建对象 //var 变量名=new Object(); Objiect是系统的构造函数 var obj=new Onject();//实例化对象 //添加属性 对象名.名字=值； obj.name=\"eureka\"; console.log(obj.name); //添加方法 对象.名字=函数; obj.say=function (){//匿名函数 console.log(\"hello world,my name is\"+obj.name); //可以使用this代替当前对象，即：this.name };//分号不能丢！ obj.say(); //一次性创造多个对象，把创建的对象的代码封装在一个函数内(工厂模式) function creatObject(name,age){ var obj=new Object(); obj.name=name;//前面的name是对象的属性，后面的是传进来的变量 obj.age=age; obj.say=function (){ console.log(\"hello world\"); }; return obj;//记得返回 } var per1=creatObject(\"eureka\",18); 2、自定义构造函数创建对象（结合第一种和需求通过工厂模式创建对象） //构造函数和函数的区别：首字母大写！ function Person(name,age){ this.name=name; this.age=age; this.say=function (){ console.log(\"hello world,my name is\"+this.name); }; } var per1=Person(\"eureka\",18); console.log(per1 instanceof Person);//判断对象类型 //创建对象时，系统做了哪些事 > 1、在内存中开辟空间，存储创建新的对象 > 2、把this设置为当前的对象 > 3、设置对象的属性和方法的值 > 4、把this这个对象返回 3、字面量的方式创建对象 var obj= {};//空对象 obj.name=\"eureka\"; //优化后 var obj={ name:\"eureka\", age:18, say:function (){ console.log(\"hello world\"); }//不加分号 }; console.log(obj.height);//undefined;点语法是不需要事先声明，没有的属性只会返回undefined //缺陷：一次性的对象 判断是否对象类型 //变量 instanceof 类型的名字 console.log(obj instanceof Object);//true or false 设置属性和方法的另一写法 obj.name=\"eureka\";//obj[\"name\"]=\"eureka\";中括号内必须为双引号； obj[\"say\"]();//调用函数的小括号不能省略 //对象中确实有这个属性，则 对象.属性 和 对象[\"属性\"]都可以 //对象没有这个属性，则只能使用对象[\"属性\"] JSON JSON格式的数据一般都是成对的，是键值对，无论是键，还是值，都是用双引号括起来的；它也是一个对象 json的数据实际上就是格式化后的一组字符串的数据 遍历对象的内容 //不能用for循环，无序 var json={ \"name\":\"eureka\", \"age\":\"18\", \"sex\":\"boy\" }; for(var key in json){//key是一个变量，存储json所有属性的名字 console.log(json[key]);//这里不能用点语法，否则undefined }//for in 语句 简单类型和复杂类型 原始数据类型：number,string,boolean,undefined,null,object 基本类型（简单类型），值类型：number,string,boolean 值类型在栈中存储 值类型传递的是值 var num1=50;//全局变量 var num2=60;//全局变量 function f1(num,num1){//50，60 num=100;//50->100,局部变量 num1=100;//60->100，局部变量 num2=100;//隐式全局变量 console.log(num);//100 console.log(num1);//100 console.log(num2);//100 } f1(num1,num2);//传50，60 console.log(num1);//50 console.log(num2);//100 console.log(num);//报错 复杂类型（引用类型）：object 引用类型的对象在堆中存储，地址在栈中存储 引用类型传递的是地址（引用） function Person(name,age,alary) { this.name=name; this.age=age; this.salary=salary; } function f1(person){ person.name=\"jack\"; person=new Person(\"mike\",18,10);//改变地址，不再指向tom这个对象，指向新的对象 } var p=new Person(\"tom\",1,1000);//p->0x120 | 0x120->tom对象 console.log(p.name);//tom f1(p);//传p这个对象的地址当参数,f1(0x120) console.log(p.name);//jack 空类型：undefined,null 三种对象 1、内置对象 js系统自带的对象 实例对象：通过构造函数创建出来，实例化的对象 静态对象：不需要创建，方法（静态方法）可以直接调用 实例方法：必须通过实例对象调用 静态方法：必须通过大写的对象调用 Math Math是一个对象，不是函数，不能实例化，直接调用属性（静态）、方法（静态）即可 Math.abs(null);//0----空，默认为0 Math.ceil(12.09);//13----向上取整 Math.floor(12.9);//12----向下取整 Math.max(10,5,6,4,45);//45----最大值 Math.min(10,5,6,4,45);//4----最小值 Math.pow(3,2);//9---3的2次方 Math.sqrt(9);//3----9的开平方根 Math.random();//随机数----[0,1),靠*、+扩大范围 Math.Pi;//圆周率 Date 需创建Date的实例对象 var dt=new Date.now();//数字型，以毫秒为单位 var dt=new Date(\"1970-01-01\");//1970,01,01 | \"1970/01/01\" |能将毫秒数转成日期对象 var dt=new Date();//当前时间---服务器的当前时间 dt.getFullYear();//获取年 dt.getMonth()+1;//月份从0开始，应加1 dt.getDate();//获取日期 dt.getHours();//获取小时 dt.getMinutes();//获取分钟 dt.getSeconds();//获取秒 dt.getDay();//获取星期，0代表星期日 dt.toDateString();//Wed Sep 13 2017 dt.toLocaleDateString();//2017/9/13 dt.toTimeString();//11:03:14 GMT+0800(中国标准时间) dt.toLocaleTimeString();//上午11:03:04 dt.valueOf();//相当于var dt=new Date.now() var dt=+new Date();//一种特殊写法，只适用Date，在浏览器不适用html5时的写法 String String 是一个用于字符串或一个字符序列（字符组成的数组）的构造函数 js中没有字符类型，即单个字母 字符串特性：不可变性，字符串的值是不可变的 //此时当做对象看待 var str=\"hello world\"; str.length;//字符串的长度 str.charAt(index);//index=[0,str.length-1] 返回指定索引位置的字符，超出索引为空 String.fromCharCode(数字值,[可以是多个参数]);//返回ASCII码对应的值,静态方法，使用 对象.方法 str.concat(string2[,string3...]);//将多个字符串与原字符串连接合并，返回新的字符串 str.indexOf(string[,给定位置的索引]);//返回这个字符串的索引，-1为not found,给定的索引可以超出str的长度 str.startswith('http://');//true|false,以什么开头 str.endsWith('http://');//true|false,以什么结尾 str.lastIndexOf(string[,给定位置的索引]);//从后往前找，索引 str.replace(替换字符,被替换字符);//将str里的字符替换成别的，返回新的字符串 str.split(\"\"[,3]);//将str以空格分割[3次]，返回数组 str.slice(5[,10]);//截取从索引5开始到[10的前一个]结束[5,10)，返回截取的字符串；允许负数，可以从后往前数 str.substr(5[,5]);//截取从序列5开始，截取到后面长度为5的字符串 str.substring(5[,10]);//截取从序列为5开始，到序列为10前[5,10)，取两者最小值为start，负数自动转为0，并为start str.toLocalLowerCase();//转为小写，效果相同的有，没多大差别str.toLowerCase(); str.toLocalUpperCase();//转为大写，效果相同的有，没多大差别str.toUpperCase(); str.trim();//切掉字符串两端的空格 Array //构造函数 var arr=new Array(); //字面量 var arr=[]; Array.isArray(obj);//判断obj是否是数组 arr instanceof Array;//同上 Array.from(arr);//将arr转成新数组 arr.concat(arr1[,arr2]);//拼接arr和arr1两个数组 arr.every(function(ele,index,array){});//ele:元素值，index:元素的索引，array：arr原数组本身，以上参数看需求添加，返回布尔值；用于判断arr的元素是否都符合函数的条件，都有则true arr.filter(function (){});//返回符合函数条件的新数组，函数的参数同上 arr.map(function(){});//数组中每个元素都要执行这个函数，返回执行后的新数组，里面可以是方法，不一定是函数 arr.push(100);//在末尾添加元素100，返回数组长度 arr.pop();//删除最后一个元素，返回值为该元素 arr.shift();//删除第一个元素 arr.unshift();//在第一个前面添加元素 arr.forEach(function (){});//参数同上，遍历数组，相当于for循环，无返回 arr.indexOf(元素值);//有则返回索引，无则-1 arr.join(\",\");//将arr以\",\"拼接成字符串返回 arr.reverse();//反转数组 arr.sort();//数组排序；不稳定，可以添加比较函数 /* function (a,b){ //a---arr[j];b---arr[j] if(a>b){ return 1; }else if(a==b){ return 0; }else{ return -1; } }//固定写法，sort就稳定了 */ arr.slice(3,4);//从索引3开始，到4前截取新的数组；[3,4) arr.splice(开始位置,删除个数,用于替换的元素);//用于删除元素或替换，或添加(删除个数为0，即添加) arr.length=0;//清空数组 2、自定义对象 自己定义的构造函数创建的对象 3、浏览器对象 基本包装类型 普通变量不能直接调用属性和方法 对象可以直接调用属性和方法 基本包装类型：本身是基本类型，但在执行代码的过程中，如果这种类型的变量调用了属性和方法，那么这种类型就不再是基本类型，而是基本包装类型，这个变量成了基本包装类型对象 var flag=new Boolean(false); var result=flag&&true;//true,如果是一个对象&&true---->true var result=true&&flag;//对象,如果是true&&一个对象---->对象 //---------------------- var num=10;//基本类型 var num=Number(\"10\");//类型转换 var num=New Number(\"10\");//基本包装类型 DOM JavaScript分三个部分 ECMAScript标准：JS的基本语法 DOM：Document Object Model ---->文档对象模型----操作页面元素---顶级对象：document BOM：Browser Object Model ---->浏览器对象模型----操作的是浏览器---顶级对象：window,页面的内容都属于window,当调用window下的属性和方法时，可以省略window，window.name输出为空 文档：一个页面可以看成一个文档 元素（element）：页面中的所有的标签都是元素，元素可以看成是对象 节点（node）：页面中所有的内容都是节点：标签，属性，文本(文字、换行、回车) 元素 获取元素 // //input 要放在document.getElementById()之前！！！动态类型 //==============获取元素================== var btnObj=document.getElementById(\"btn\");//根据id获取元素，返回一个元素对象 //为当前的这个按钮元素（对象），注册点击事件，添加事件处理函数（匿名函数） btnObj.onclick=function (){ alart(\"hello world\"); }; document.getElementsByTagName(\"p\");//返回所有p标签组成的伪数组，需用for遍历每个数组 //============下面的有的浏览器不支持/IE低版本的=============== document.getElementsByName(\"name1\");//获取name=\"name1\"的所有表单，返回伪数组 //基本标签没有name值，表单标签才有 document.getElementsByClassName('cls');//获取class=\"cls\"的所有元素，返回伪数组，属于H5 document.querySelector(\"#btn\");//根据选择器的方式获取元素，获取id=\"btn\"的元素，返回一个 document.querySelectorAll(\".cls\");//根据选择器获取所有class=\".cls\"的元素，返回多个 //=============this================== btnObj.onclick=function (){ this.value=\"hello\"; };//在某个元素的事件中，在本事件中的this就是当其的元素对象 var inputs = document.getElementsByTagName('input'); for (var i = 0; i 男 女 保密 /* document.getElementById(\"btn\").onclick=function (){ document.getElementById(\"rad1\").checked=true;//默认选中 }; 表单标签中，如果属性和值只有一个，并且是该属性本身，那么，DOM操作时，这个属性值是布尔类型就可以了 */ //=============多单词写法====================== /* document.getElementById(\"dv\").style.backgroundColor=\"yellow\"; 凡是css的属性是多个单词的写法，DOM操作时，可将-去掉，后面的单词首字母大写即可 */ //==============className================= .cls {width:100px;heigth:100px} // document.getElementById(\"dv\").className=\"cls\";//在js代码中，设置元素的类样式，不能用class关键字，应用className // =========classList========== document.getElementById(\"dv\").classList.add('cls'); document.getElementById(\"dv\").classList.remove('cls'); document.getElementById(\"dv\").classList.toggle('cls'); //当只有一个参数时：切换 class value; 即如果类存在，则删除它并返回false，如果不存在，则添加它并返回true。 //当存在第二个参数时：如果第二个参数的计算结果为true，则添加指定的类值，如果计算结果为false，则删除它 /* 与className类似 使用“classList”，可以添加或删除一个类，而不会影响该元素可能具有的任何其他类。但是如果你指定“className”，它将在添加新类时消灭任何现有的类（或者如果你指定一个空字符串，它将消除所有类） 配“className”可以方便确定元素上不会使用其他类，通常只使用“classList”方法。 而且“classList”也有方便的“切换”和“替换”方法。 */ //==============对元素操作================ /*阻止超链接的默认跳转：return false 如果是addEventListener等的兼容代码，在函数内部return false无效， 需在兼容函数后加document.getElementById('aa').setAttribute(\"onclick\",\"return false;\"); 原因：相当于下面代码 obj.onclick=function(){ addEventListener();上面的只有跳出第一层，应该在最外一层加 } */ //鼠标点击：获取的元素.onclick //鼠标经过：获取的元素.onmouseover //鼠标离开：获取的元素.onmouseout //搜索框获取焦点：获取的元素.onfocus //搜索框失去焦点：获取的元素.onblur //设置成对的标签中的文本内容：获取的元素.innertText//IE8的标准 //设置成对的标签中的文本内容：获取的元素.textContent//W3C的标准，IE8不支持 //设置文本内容、设置html标签：获取的对象.innerHtml//推荐使用这个设置文本，相对前两个没有兼容问题；也可以设置带标签的内容，且有标签效果。获取时也会带标签获取 //=============兼容代码============= //浏览器不支持，返回undefined function setInnerText(element,text){ if(typeof element.textContent==\"undefined\"){//不支持 element.innerText=text; }else{ element.textContent=text; } } //=========标签中自定义属性=============== //hello world this.getAttribute(\"score\");//获取自定义属性的值，直接.会得到undefined lis[i].setAttribute(\"score\",(i+1)*10);//批量设置标签的自定义属性，直接.在标签中看不到，缓存在DOM中 this.removeAttribute(\"score\");//移除自定义属性 this.removeAttribute(\"class\");//也可移除自带属性；相比于把值设空，本法更为干净，属性名都删除了 //========排他功能=================== for(var i=0;i 节点 nodeType：节点类型==1---标签，2---属性，3---文本（文本，换行，回车） nodeName：节点名字==标签节点---大写的标签名，属性节点---小写的属性名，文本节点---#text nodeValue：节点值==标签节点---null，属性节点---属性值，文本节点---文本内容 var ulObj=documenet.getElementById(\"uu\"); ulObj.parentNode;//父级节点 ulObj.parentElement;//父级元素 ulObj.childNodes;//子节点 ulObj.children;//子元素可以 //=======以下IE8只支持第一种，而且获取的变成元素，不是节点，第二中会变成undefined=========== ulObj.firstChild;//第一个子节点 ulObj.firstElementChild;//第一个子元素 ulObj.lastChild;//最后一个子节点 ulObj.lastElementChild;//最后一个子元素 ulObj.previousSibling;//某元素的前一个兄弟节点 ulObj.previousElementSibling;//某元素的前一个兄弟元素 ulObj.nextSibling;//某元素的后一个兄弟节点 ulObj.nextElementSibling;//某元素的后一个兄弟元素 ulObj.getArributeNode(\"id\");//获取属性为id的属性 //获取的节点可以.nodeType.... 元素创建 为了提高用户的体验 元素创建的三种方式： //1、docunment.write(\"标签的代码及内容\");========创建的是一个字符串 docunment.write(\"这是一个p\"); //缺陷：如果在页面加载完毕后，此时通过此法，页面（head、body）上的其他内容都被清除；但在加载时使用此法不会清除 //2、对象.innerHTML=\"标签代码及内容\";==========创建的是一个字符串 var divObj=document.getElementById(\"dv\"); divObj.innerHTML=\"这是一个p\"; //谁要创建子元素，就在谁后面.;不能放在body里，相当重新赋值，会清除原始数据 //3、document.creatElement(\"标签名字\");==========创建的是一个对象 var pObjs=document.createElement(\"p\");//创建元素，标签名 var ulObj = document.createElement(\"ul\");//如果要获取这个ul对象，直接调用ulObj就行，这个变量存储在内存中，只要页面不关闭，就能调用 pObjs.innerText=\"这是一个p\";//p标签增加内容 divObj.appendChild(pObj);//将创建好的元素追加到父元素中！！，创建好后要追加！这里可以无限在后面追加 divObj.insertBefore(pObj,divObj.firstElementChild);//把新的元素添加到第一个子元素之前 divObj.replaceChild(pObj,divObj.firstElementChild);//与第一个子元素替换 divObj.removeChild(divObj.firstElementChild);//删除第一个子元素 //解决appendChild无限追加的bug-------有则删除，无则创建---------------- // // var divObj = document.getElementById('dv'); document.getElementById('btn').onclick = function() { if (document.getElementById('btn2')) {//有则删除 divObj.removeChild(document.getElementById('btn2')); } var inputObj = document.createElement(\"input\"); inputObj.type = \"button\"; inputObj.value = \"按钮\"; inputObj.id=\"btn2\"; divObj.insertBefore(inputObj,divObj.firstElementChild); }; Tips： 如果是循环内添加事件，推荐使用命名函数，节省内存空间 如果是在循环的外面添加事件，推荐使用匿名函数 为同一个元素绑定多个事件 document.getElementById(\"dv\").onclick=function (){};//只能绑定一个事件 //================================= document.getElementById(\"dv\").addEventListener(\"click\",function(){},false); //对象.addEventListener(\"事件类型\",事件处理函数,false);谷歌火狐支持，IE8不支持 //参数1：事件的类型---事件的名字，没有on，string类型 //参数2：事件处理函数---函数（命名函数、匿名函数） //参数3：布尔类型，false----事件冒泡阶段，true----事件捕获阶段 //================================== document.getElementById(\"dv\").attachEvent(\"onclick\",function(){}); //对象.attachEvent(\"有on的事件类型\",事件处理函数);谷歌火狐不支持，IE8支持 //参数1：事件的类型---事件的名字，有on！ //参数2：事件处理函数---函数（命名函数、匿名函数） 为元素解绑事件 document.getElementById(\"btn\").onclick=null;//为id为btn的按钮事件解绑 /* tips： 用什么方式绑定事件，就应该用对应的方式解绑事件 1、解绑事件： 对象.on事件名字=事件处理函数----->绑定事件 对象.on事件名字=null;---->解绑 2、解绑事件 对象.addEventListener(\"没有on的事件类型\"，命名函数，false);-----绑定事件；不能用匿名函数，不是同一个函数 对象.removeEventListener(\"没有on的事件类型\"，函数名字，false);-----解绑事件 3、解绑事件 对象.attachEvent(\"有on的事件类型\"，命名函数);----绑定事件 对象.detachEvent(\"有on的事件类型\"，函数名字);----解绑事件事件 */ 事件冒泡 多个元素嵌套，有层次关系，这些元素都注册了相同事件，如果里面的元素触发了，外面的元素的该事件自动的触发了 document.getElementById(\"dv1\").onclick=function(){ console.log(\"hello world\"); }; document.getElementById(\"dv2\").onclick=function(e){//IE8没有这个参数，udefined console.log(\"hello world\"); window.event.cancelBubble=true;//在这层停止，dv1不触发 IE、谷歌支持，火狐不支持 e.stopPropagation();//IE8不支持 ，谷歌、火狐支持 }; document.getElementById(\"dv3\").onclick=function(){ console.log(\"hello world\"); }; 事件捕获阶段：从外向内 2->事件目标阶段：最开始选择的那个 3->事件冒泡阶段：从里向外 一般默认都是冒泡阶段，很少捕获阶段 --> 为同一元素绑定多个事件，指向相同事件处理函数 var mouseObj = document.getElementById('btn'); mouseObj.onclick = f1; mouseObj.onmouseover = f1; mouseObj.onmouseout = f1; function f1(e) {//谷歌、火狐才有e switch (e.type) {//没有on的事件名 case \"click\": console.log(\"hello world\"); break; case \"mouseover\": this.style.backgroundColor = \"red\"; break; case \"mouseout\": this.style.backgroundColor = \"green\"; break;4 } } BOM window.onload=function(){};//页面加载完毕，这个事件就会触发----标签、属性、文本、外部引入的js文件，window可以省略 window.onunload=function(){};//扩展事件----页面关闭后才触发的事件，IE8才有 window.onbeforeunload=function(){};//扩展事件----页面关闭之前触发的事件，IE8才有 location对象 获取或者设置浏览器地址栏的URL，window可以省略 //属性 location.hash;//得到地址栏上#及后面的内容 location.host;//主机名及端口号 location.hostname;//主机名 location.pathname;//文件的路径----相对路径 location.port;//端口号 location.portocol;//协议 location.search;//s?搜索的内容 location.href=\"http://www.baidu.com\";//要调转的地址 //方法 location.assign(\"http://www.baidu.com\");//要调转的地址 location.reload();//重新加载 location.replace(\"http://www.baidu.com\");//替换地址，没有历史记录 history对象 history.back();//后退 history.forward();//前进 history.go();//取决于内容，正数前进，负数后退 navigator对象 navigator.userAgent;//判断用户浏览器类型 navigator.platform;//判断系统平台类型 定时器 setInterval();//常用的，反复执行 /* 参数1：函数 参数2：时间，毫秒为单位 执行过程：页面加载完毕后，每过x毫秒，执行一次函数 返回值：定时器的Id cleanInterval(timeId); 参数：要清理的定时器的Id */ setTimeout();//一次性定时器，只执行一次，但是还是占内存空间、 /* 参数、返回值同上 clearTimeout(timeId); 用于定时器，释放空间 */ Tips: //如果要获取div的left值(无论是在标签还是属性)，可以使用 document.getElementById.offsetLeft;//数字类型，没有px，而不能用my$(\"dv\").style.left //获取任意一个元素的任意一个样式属性的值 兼容代码,offsetLeft 要脱标left的值才有效 function getStyle(element, attr) {//返回字符串类型 return window.getComputedStyle?window.getComputedStyle(element, null)[attr]:element.currentStyle[attr]||0; } } //移动盒子动画案例： function moveElement(element, json) { //元素 json{属性名字:目标位置} clearInterval(element.timeId); //先清理定时器,保证每次都是同一个定时器 element.timeId = setInterval(function() { //对象的属性唯一，不会重复创建定时器 var flag = true; //假设默认全部到达位置 for (var attr in json) { var current = parseInt(getStyle(element, attr)); var target = json[attr]; //动态步距，最后每一步走1像素，直到目标位置停下 var step = (target - current) / 10; //0.1取1,-0.1取-1。应往大了取才会到 step = step > 0 ? Math.ceil(step) : Math.floor(step); current += step; //到最后每步走一像素，肯定不会超出 element.style[attr] = current + \"px\"; if (current != target) { flag = false; //只要有一个没到达目标就false } } if (flag) {//所有元素到达指定位置，清理定时器 clearInterval(element.timeId); //清理定时器 } }, 20); } //克隆元素 var new=ulObj.children[0].cloneNode(true);//克隆ulObj中的第一个子元素，true---包括属性，false---不包括属性 ulObj.appendChild(new);//添加到ulObj的子元素后面 offset系列 如果样式的代码是在style标签中设置，外面是获取不到的 | 如果样式的代码是在style属性中设置外面是可以获取到的 | style=\" \" offsetWidth：获取元素的宽 offsetHeight：获取元素的高（自身的高+自身的border） offsetLeft：获取元素的距离左边位置的值 offsetTop：获取元素的距离上面位置的值 没有脱离文档流： offsetLeft：父级元素margin+父级元素padding+父级元素border+自己的margin 脱离文档流： offsetLeft：只跟自己的left和margin有关系 可直接通过document获取的 document.body;//获取body，body标签 document.title;//获取title,title内的内容 document.documentElement;//获取html，html标签 元素跟随鼠标移动 document.onmousemove = function(e) { var imgObj = document.getElementById('img'); imgObj.style.left = e.clientX + \"px\";//可视区域的X坐标 imgObj.style.top = e.clientY + \"px\"; } scroll系列 scrollWidth：元素中内容的实际的宽（没有边框），如果没有内容（或者内容不足盒子高度）就是元素的宽 scrollHeight：元素中内容的实际的高（没有边框），如果没有内容（或者内容不足盒子高度）就是元素的高 scrollLeft：向左滚动（卷曲）出去的距离 scrollTop：向上滚动（卷曲）出去的距离 //实时获取滚动条向上滚动的距离 document.getElementById('dv').onscroll=function () {//获取id为dv的div的滚动事件 console.log(this.scrollTop); }; //封装获取scroll值的兼容代码 function getScroll() { return { left:window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0; top:window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0; }; } //获取任意一个元素的任意一个样式属性的值 兼容代码,offsetLeft 要脱标left的值才有效 function getStyle(element, attr) {//返回字符串类型 if (window.getComputedStyle) { return window.getComputedStyle(element, null)[attr];//谷歌、火狐支持 } else { return element.currentStyle[attr];//IE8支持 } }//上面的可以简写成3元表达式 变速动画函数 //获取任意一个元素的任意一个样式属性的值 function getStyle(element, attr) { if (window.getComputedStyle) { return window.getComputedStyle(element, null)[attr]; } else { return element.currentStyle[attr]; } } //动画函数 function moveElement(element, json, fn) { //元素 json{属性名字:目标位置} fn回调函数 clearInterval(element.timeId); //先清理定时器,保证每次都是同一个定时器 element.timeId = setInterval(function() { //对象的属性唯一，不会重复创建定时器 var flag = true; //假设默认全部到达位置 for (var attr in json) { // 循环遍历json中的每个属性 if (attr == \"opacity\") { //将返回的数字字符串*100转成数字，透明度放大100倍 var current = getStyle(element, attr) * 100; //透明度放大100倍 var target = json[attr] * 100; //动态步距，最后每一步走1像素，直到到达目标位置停下 var step = (target - current) / 10; //0.1取1,-0.1取-1。应往绝对值大了取才会到 step = step > 0 ? Math.ceil(step) : Math.floor(step); current += step; //缩小为原来大小 element.style[attr] = current / 100; } else if (attr == \"zIndex\") { //改变层级 element.style[attr] = json[attr]; } else { //普通属性 //将返回的字符串转变为数字 var current = parseInt(getStyle(element, attr)); //目标位置 var target = json[attr]; //动态步距，最后每一步走1像素，直到到达目标位置停下 var step = (target - current) / 10; //0.1取1,-0.1取-1。应往绝对值大了取才会到 step = step > 0 ? Math.ceil(step) : Math.floor(step); current += step; //到最后每步走一像素，肯定不会超出 element.style[attr] = current + \"px\"; } //是否到达目标位置 if (current != target) { flag = false; //只要有一个没到达目标就false } } if (flag) { //所有属性都到达目标 clearInterval(element.timeId); //清理定时器 if (fn) { //如果回调函数存在，则调用 fn(); } } }, 20); } client系列 可视区域 clientWidth:可视区域的宽（没有边框），边框内部宽度 clientHeight:可视区域的高（没有边框），边框内部高度 clientLeft:左边边框的宽度 clientTop: 上面边框的宽度 clientX:可视区域的横坐标 clientY:可视区域的纵坐标 document.onmousemove = function(e) { e = window.event || e; document.getElementById('im').style.left = e.clientX + \"px\"; document.getElementById('im').style.top = e.clientY + \"px\"; }; 阻止超链接跳转 document.getElementById(\"ak\").onclick=function (e) { alert(\"hello\"); return false;//第2种 e.preventDefault();//第3种 }; onmousedown;// 鼠标按住 onmouseup;// 鼠标松开 window.getSelection ? window.getSelection().removeAllRanges() :document.selection.empty();//鼠标按住滑动不选取内容 隐藏元素 //不占位 my$(\"dv\").style.display=\"none\"; //占位 my$(\"dv\").style.visibility=\"hidden\"; //占位 my$(\"dv\").style.opacity=0; //占位 my$(\"dv\").style.height=\"0px\"; my$(\"dv\").style.border=\"0px solid red\"; 面向对象 构造函数与实例对象之间的关系 1、实例对象是通过构造函数来创建的----创建的过程叫实例化 2、如何判断对象是不是这个数据类型？ ​ 1）通过构造器的方式 实例对象.构造器(constructor)==构造函数名字 ​ 2）对象 instanceof 构造函数名字（推荐） 原型 通过原型来添加方法，解决数据共享，节省内存空间 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.eat = function() {//原型 console.log(\"hello world\"); }; //简单的原型写法 Person.prototype = { constructor:Person,//需要手动添加构造器 height:\"188\", study:function () { console.log(\"hello\"); } }; 实例对象中有个属性，__proto__，也是对象，叫原型，不是标准的属性，供浏览器使用 构造函数中有个属性，prototype，也是对象，叫原型，是标准属性，供程序员使用 原型--->__proto__或者是prototype，都是原型对象 原型的作用：数据共享，节省内存空间 实例对象使用的属性和方法，现在实例中查找，再到实例对象的__proto__指向的原型对象prototype中找，直到找不到返回undefined。有则返回 要对实例对象添加属性或者方法可以通过原型添加 把局部变量给window就变成全局变量 (function (window){ var num=10; window.num=num; })(window); bind()函数 在函数后添加，改变函数内的this为指定的对象 var that=null; function Person(name){ that=this; this.name=name; } function Animate(){ console.log(this.name);//此时this为Person的实例对象 }.bind(that) 原型链： 是一种关系，实例对象和原型对象之间的关系，关系是通过原型（__ proto __)来联系的 原型的指向是可以改变的，通过改变构造函数的原型（prototype） 只要是实例对象就有__proto__，只要是__proto__，就指向某个构造函数的原型 原型最终指向null Person的实例对象的__proto__指向Person的prototype，Person的prototype的__proto__指向Object的prototype，Object的prototype的__proto__指向null 继承 首先继承是一种关系，类（class）与类之间的关系，JS中没有类，但是可以通过构造函数模拟类，然后通过原型来实现继承 继承也是为了数据共享，js中的继承也是个为了实现数据共享 原型的作用： 1、数据共享、节省内存空间 2、为了实现继承 function Person(age){ this.age=age; } function Student(score){ this.score=score; } //原型继承 Student.prototype=new Person(10);//继承了人的所有属性、方法 Student.prototype.study=function (){ console.log(\"studing!\"); };//应该放在改变指向之后！ //缺陷，age等属性值只能通过重新赋值改变 //更新----借用构造函数：函数名字.call(this,...); function Student(age,score){ Person.call(this,age);//继承了Person的属性及方法 this.score=score; } //缺陷：父级对象（Person）的方法不能继承 //更新----组合继承：原型继承+借用构造函数继承 function Student(age,score){ Person.call(this,age);//继承了Person的属性及方法 this.score=score; } Student.prototype=new Person();//不传值！ //还有拷贝继承 //直接把对象需要的属性和方法循环遍历复制到另一个对象 高阶函数 函数的声明和函数表达式的区别 if (true) { function f1() { console.log(\"hello\"); } } else { console.log(\"hello world\"); } f1();//在if-else中，IE8会变成hello world！ //换成函数表达是就不会了 f1=function(){}; this的指向 //普通函数的this function f1(){ console.log(this); } f1();//window--->window.f1() //定时器的this setInterval(function(){ console.log(this); },1000)//window--->window.setInterval() //构造函数中的this---->实例对象 //对象.方法中的this---->实例对象 //原型对象中的方法的this---->实例对象 //========================= //当严格模式下 \"use strict\";//严格模式 f1();//undefined window.f1();//window 函数是对象，对象不一定是函数 对象中有__proto__，函数中有prototype 所有的函数都是Funtion的构造函数创建出来的实例对象 apply和call 调用的时候，可以改变this的指向 function f1(x, y) { console.log((x + y) + \"====>\" + this); return \"这是函数的返回值\"; } f1(10, 20); var obj = { age: 10, }; f1.apply(obj, [10, 20]);//此时的this是obj f1.call(obj, 10, 20);//此时的this是obj //使用方法：参数的传递方式不一样,作用一样 //函数名字.apply(对象,[参数1,参数2,...]); //方法名字.apply(对象,[参数1,参数2,...]); //函数名字.call(对象,参数1,参数2,...); //方法名字.call(对象,参数1,参数2,...); bind方法 复制的意思，参数可以在复制时传进去，也可以在复制之后调用时再传 function Person(age) { this.age = age; } Person.prototype.say = function() { console.log(\"hello:===>\" + this.age); }; function Student(age) { this.age = age; } var per = new Person(10); var stu = new Student(20); var ff = per.say.bind(stu); ff(); //使用语法 //函数名字.bind(对象,参数1,参数2...);---->返回值是复制之后的这个函数 //方法名字.bind(对象,参数1,参数2...);---->返回值是复制之后的这个方法 函数中的几个成员 函数中有name属性--->函数名 函数中有arguments属性--->实参的个数 函数中有length属性--->函数定义时形参的个数 函数中有caller属性--->调用该函数者 判断是否是某个类型 1、typeof 变量 2、变量 instanceof 类型 3、Object.prototype.toString.call(要判断的实例对象); 闭包 闭包的概念:函数A中,有一个函数B(或对象),函数B(或对象)中可以访问函数A中定义的变量或者是数据,此时形成了闭包(这句话暂时不严谨) 闭包的模式:函数模式的闭包,对象模式的闭包 闭包的作用:缓存数据,延长作用域链 闭包的优点和缺点:缓存数据 总结：如果想缓存数据，就把这个数据放在外层函数和里层函数之间 局部变量是在函数中，函数使用结束后，局部变量就会被自动的释放 闭包后，里面的局部变量的使用作用域链就会被延长 function f1() { var num=parseInt(Math.random()*10+1); return function () { console.log(num); } } var f2=f1(); f2(); f2(); f2();//每次获取的都是相同的随机数 沙箱 就是一个环境，也叫黑盒，在这个环境中模拟外面真实的开发环境，完成需求，效果和外面的真实环境是一样的。 避免命名冲突 (function (){ }());//相当于一个沙箱，里面的局部变量在这个函数相当于全局变量 //全局变量只有在页面关闭之后才会释放，所以多使用局部变量 //好处：将一段功能相似的代码封装在沙箱（自调用函数）中，可以避免变量名冲突，又可以节省内存 递归 函数中调用自己，此时就是递归，递归一定要有结束的条件 递归效率很低 function getFi(x) { if (x==1||x==2) { return 1; } return getFi(x-1)+getFi(x-2); } console.log(getFi(12)); 浅拷贝 把一个对象中的所有内容复制一份给另一个对象，直接复制或者说就是把一个对象的地址给了另一个对象，他们的指向相同 slice(0) ,[...arr2] = arr1,...属于浅拷贝 注意：如果 子元素 含有复杂对象 深拷贝 会 引用它的地址，而不是创建新的子元素 // eg. // 如果 [[0,0],[1,1],[2,2]] 这种 子元素属于复杂对象的 ，浅拷贝只会复制第一层 // 里面的 [0,0] 、[1,1]、[2,2] 是引用原来的数组的地址，改变 [0,0] ==>[1,0] 原来的数组也会改变 深拷贝 把一个对象中的所有属性和方法，一个个找到，并且在另一个对象中开辟相应的空间，一个个的存储到另一个对象中 注意：如果 子元素 含有复杂对象 深拷贝 会 创建新的子元素 ，而不是引用它的地址 正则表达式 作用：匹配字符串的 组成：有元字符或者是限定符组成的一个式子 元字符： . 表示除\\n以外的任意一个字符 [] 表示一个范围：[0-9a-z] 或者把元字符的意义去掉：[.] | 表示或者 () 分组，提升优先级 ()* 前面的表达式出现了0次或多次 {0,} ()+ 前面的表达式出现1次或多次 {1,} ？ 前面的表达式出现0次或1次;或者阻止贪婪模式 {0,1} ^ 以...开始，或者取非 ^[0-9]以数字开头 [ ^0-9]非数字 $ 以...结束 \\d [0-9] \\D 非数字 \\s 空白符 \\S 非空白符 \\w 非特殊符号[0-9a-zA-Z_] \\W 特殊符号 \\b 单词边界 邮箱 ^[0-9a-zA-Z_.-]+[@][0-90-9a-zA-Z_.-]+([.][a-zA-z]+){1.2}$//严格模式 创建正则表达式 //1、通过构造函数创建对象 var str=\"hello world\"; var reg=new RegExp(/\\d{5}/); var falg=reg.test(str);//返回true或false reg.exec(str);//与下面的match类似，不过调用一次只能输出一个.若reg里添加g，就是全局;要多次输出需多次调用console.log(reg.exec(str)); str.match(reg);//返回str里面符合reg条件的字符串,只匹配一次 str.match(/\\d{5}/g);//g表示全局，匹配所有,返回符合条件的数组 var arr=str.match(/(\\d{4})[-](\\d{2})[-](\\d{2})/g); console.log(RegExp.$3);//获取第3组，每个小括号为一组(数左括号是第几个)，通过正则表达式对象.$ str.replace(/1/g,\"2\");//将所有1替换成2 str.replace(/h/gi,\"s\");//将所有h,并忽略大小写，替换成s //2、字面量的方式 var reg=/\\d{5}/; var falg=reg.test(str); 中文与编码转换 控制台 escape(\"中文\"); unescape(\"%u4E2D%u6587\"); //中文范围：[\\u4e00-\\u9fa5] 数组与伪数组 真数组的长度是可变的，可以使用数组中的方法，真数组的__proto__指向的是Array的prototype 伪数组的长度是不可变的，不可以使用数组中的方法 var arr=[0,1,2,3];//真数组 var arr={ 0:0, 1:1, 2:2, 3,3, length:4 }//伪数组 "},"JavaScript/add/":{"url":"JavaScript/add/","title":"JavaScript 补充","keywords":"","body":"JavaScript 补充 本章主要介绍两个方面的内容： EcmaScript6 "},"JavaScript/add/EcmaScript6.html":{"url":"JavaScript/add/EcmaScript6.html","title":"EcmaScript6","keywords":"","body":" 参考书籍：EcmaScript6 入门 变量声明的扩展：let 和 const var： 作用：变量声明 var的缺陷：变量提升，可以重复声明 作用域：全局作用域，函数作用域 没有块级作用域 在浏览器中默认属于 window let： 作用：变量声明 块级作用域（被\"{}\"扩起来的） 没有变量提升 必须先声明后使用 不允许重复声明 const： 作用：常量声明 常量：一旦声明不可改变 只读：普通数据类型不能修改 复杂数据类型 可以修改 不能重新赋值 声明同时必须赋值 块级作用域 没有常量提升 不可重复声明 字符串的扩展： includes 'hello world'.includes('hello')// true，包含 hello startsWith 'hello world'.startsWith('hello')// true，以 hello 开头 endsWith 'hello world'.endsWith('d')// true，以 d 结尾 repeat 'hello world'.repeat(2)// 'hello worldhello world' 重复2次 模板字符串、 // 可以换行 变量拼接很方便 var user= { name:'jack', age:18 } var greeting = ` 大家好，我叫${user.name}， 我今年${user.age}岁了 ` 数组的扩展 includes var arr = ['a', 'b', 'c']; var arr1 = ['a',, 'c']; arr.includes('c', 3); //false arr.includes('c', 100); // false arr.includes(); // true 判读 是否有空元素 解构赋值 本质属于 模式匹配 如果解构不成功，变量的值就是 undefined 数组的解构赋值 var arr = ['hello', 'world'] // var str1 = arr[0] // var str2 = arr[1] // 数组解构赋值是按照 索引 顺序来解构的 // 可以设定解构不成功的默认值 var [str1, str2='hi'] = arr 对象的解构赋值 var user = { name:'jack', age:18 } // 对象解构赋值是按照 键名 来解构的 // 支持设置解构不成功的默认值 var {name,age,gender = '男'} = user 字符串的解构赋值 var [a,b,c,d,e] = 'hello' // a = h ,b = e,.... 函数参数的解构赋值 var nums = [1,2] function add([x,y]){ // var [x,y] = nums return x + y } add(nums) function ajax({ url, type = get }){ console.log(url,type) } ajax({ url:'/hello', type:'post' }) 用途 交换变量的值 var x = 1 var y = 2 [x, y] = [y, x] 输入模块的指定方法 var {readFile,writeFile} = require('fs') readFile('./index.html','utf8',function(err,data){ ... }) 数值的扩展 Number Number.isFinite() Number.isNaN() Number.parseInt() // 将全局的 parseInt() 函数，转为 Number 的方法 使语法更为模块化 Number.parseInt('123')// 123 Number.parseFloat() Number.isInterger() Math 函数的扩展 函数参数的默认值 需要一个参数有默认值 最好把该参数作为尾参数 因为只有尾参数才可以省略 函数参数支持解构 函数参数的 rest 参数 rest 参数后面不能跟形参了 接收所有剩余参数放到一个 数组 中 建议以后不使用 arguments 参数（伪数组），用 args 代替 function add(...args){ console.log(args) } add(1,2,3,4,5) // [1,2,3,4,5] 箭头函数 函数声明不能使用箭头函数 函数表达式可以使用箭头函数 匿名函数可以使用箭头函数(箭头函数多用于匿名函数) 语法 一个参数可以省略() 没有参数不能省略() 函数体只有一句代码可以省略() 如果省略了{}则不能显示return var add = function (x,y) { return x + y } var add (x, y) => { return x + y} // 简写 var add x => x // 用于匿名函数 简化代码 var arr = ['a', 'b' ,'c'] arr.forEach(item => console.log(item)) 箭头函数不能当做构造函数，不能new 箭头函数内部不要使用 arguments 对象，有问题 箭头函数内部使用 rest 参数代替 arguments 箭头函数默认自动 bind(this) 由于没有自己的 this ，所以call、apply、bind无效 // 箭头函数自动绑定外部的this bind(this) function foo() { setTimeout(() => { console.log('id:', this.id);// 不是 windows 而是 { id:42 }这个对象 }, 100); } var id = 21; foo.call({ id: 42 });// id: 42 // 例2 function Person(){ this.name = 'jack', this.age = 18 } Person.prototype.greeting = function (){ window.setTimeout(() => { console.log(this) },1000) } var p1 = new Person() p1.greeting()// p1 这个实例对象 // 箭头函数无法通过 call、apply、bind 手动改变 this 指向 // 它内部的 this 都是取决于外部环境 var fn = () => console.log(this) var foo = {} fn()// window 对象 fn.call(foo)// window 对象 Promise对象 参考书籍：ECMAScript 6 入门 callback hell 异步编程无法保证执行顺序 ---> 回调嵌套 ---> 嵌套过深，代码可读性差 EcmaScript 6 中新增了一个 API：Promise Promise 是一个构造函数，在Promise中存放一个异步任务(pending) ---> resolve | reject 基本语法： var fs = require('fs') function pReadFile(filePath) { return new Promise(function (resolve, reject) { fs.readFile(filePath, 'utf8', function (err, data) { if (err) { reject(err) } else { resolve(data) } }) }) } // then(fun1,fun2) fun1 就是上面的resolve，fun2就是上面的reject(可以省略) pReadFile('./data/a.txt') .then(function (data) {// 当读取成功的时候 console.log(data) // 当前函数中 return 的结果就可以在后面的 then 中 function 接收到 // 没有 return 后面收到的就是 undefined // 我们可以 return 一个 Promise 对象 // 当 return 一个 Promise 对象的时候，后续的 then 中的 方法的第一个参数会作为第二个异步操作的 resolve return pReadFile('./data/b.txt') }) .then(function (data) { console.log(data) return pReadFile('./data/c.txt') }) .then(function (data) { console.log(data) }) "},"JavaScript/advanced.html":{"url":"JavaScript/advanced.html","title":"JavaScript 高级","keywords":"","body":""},"JavaScript/jQuery.html":{"url":"JavaScript/jQuery.html","title":"jQuery","keywords":"","body":"jQuery介绍 jQuery：就是JavaScript库中的一种，免费的 JavaScript库：把一些浏览器兼容性的代码或者是常用的函数封装在一个js文件中，这个文件就是一个JavaScript库也可以叫JavaScript函数库，如Prototype、YUI（网络反响一般）、Dojo、ExtJS、jQuery等 jQuery中的顶级对象：jQuery----可以用$符号来代替，为了方便，jQuery（jQuery的js文件中的所有东西都是jQuery或者$符号下的的） DOM对象与jQuery对象 通过DOM方式获取的-------DOM对象 通过jQuery或$方式获取的-----jQuery对象，不是同一个对象 DOM对象 转 jQuery对象：$(DOM对象); jQuery对象 转 DOM对象：jQuery对象[0]; 或者jQuery对象.get(0); 注意： .css(\"属性\",\"值\");属性的写法可以是DOM操作中的js写法，也可以是css中的写法，建议js的写法 this是DOM对象，需$(this)转成jQuery 页面加载事件 //DOM的写法，只能同时存在一个，多个只执行最后一个 window.onload = function() { console.log(\"hello\"); }; //下面的可以同时存在多个 //jQuery的第一种写法 $(window).load( function() { console.log(\"hello\"); } ); //jQuery的第二种写法---比上面快---页面中基本的元素加载后就触发 $(document).ready(function(){ console.log(\"hello\"); }); //jQuery的第三种写法---跟上面的一样---页面中基本的元素加载后就触发 $(function(){ console.log(\"hello\");//要执行的代码，上面的function不能省略 });//或者$用jQuery代替 jQuery中获取元素 $(\"选择器\");/* $(\"#btn\");id $(\".dv\");类样式 $(\"p\");标签名 $(\"p.cls\");交集选择器 $(\"#btn,p,.cls\");并集选择器 以下是后代（层次）选择器 $(\"#dv span\");获取id为dv的所有子代span $(\"#dv\").find(\"span); $(\"#dv>span\");获取id为dv的直接子代span $(\"#dv~span\");获取id为dv后面的所有兄弟span $(\"#dv+span\");获取id为dv后面的直接（相邻）兄弟span $(\"#dv\").siblings(\"span\");查找兄弟节点，不包括自身 $(\"#dv\").next();找下一个兄弟;获取所有nextAll();会断链 $(\"#dv\").prev();找上一个兄弟;获取所有prevAll();会断链 $(\"#dv\").parent();查找父类 $(\"#dv\").children(\"span\");查找子类 $(\"#uu>li\").eq(2);索引为2的li $(\"li:eq(2)\") */ jQuery中获取/设置表单标签的value jQuery对象.val();//---------表示的是获取该元素的value属性值 jQuery对象.val(\"值\");//---------表示的是设置该元素的value属性值 hello $(\"s1\").val(1);//默认下拉菜单value为1的选中，只有这个会，单选和复选是该value值 数组操作 //html5新属性 //判断数组内是否含有某值 var arr = [] var id = '3' arr.includes(id) jQuery获取/设置文本内容 jQuery对象.text();//-------获取文本内容，等价与DOM中的innerText jQuery对象.text(\"值\");//--------设置该元素的文本内容 $(\"p\").text(\"hello\");//若p有多个，不需循环 //本身代码没有循环操作，jQuery中内部帮助我们循环操作的------>隐式迭代 jQuery设置css样式 jQuery对象.css(\"css的属性名\",\"属性值\");//-----------设置元素的样式属性值 //括号内也可以传入json格式的数据 //要获取某css样式，可以调用以下方法 jQuery对象.css(\"css的属性名\");//获取的是字符串类型 //注意css()方法不能移除也不能添加类样式 jQuery获取/设置 html $(\"div\").html(\"this is a p\");//相当与DOM中的innerHTML,相当于赋值，会把原来的覆盖掉 选择奇数偶数子元素 $(\"#dv>li:odd\").css(\"width\",\"100px\");//奇数---odd $(\"#dv>li:even\").css(\"width\",\"100px\");//偶数---even 鼠标进入和离开 $(\".dv>ul>li\").mouseenter(function (){ $(this).children(\"ul\").stop().show();//当前的li中所有的ul子元素显示，show里可以添加时间，show(1000),用1秒显示;添加stop(),执行结束才执行下一次。 });//相当与DOM的onmouseover，但比mouseover好 $(\".dv>ul\").mouseleave(function (){ $(this).children(\"ul\").hide();//当前的li中所有的ul子元素隐藏 });//相当与DOM的onmouseout，但比mouseout好 索引 var index=$(this).index();//当前元素的索引 $(\"#dv>li:eq(\"+index+\")\")//:eq---选择器---获取对应索引的元素 链式编程 对象不停的调用方法 对象调用方法，如果返回值还是当前对象，那么就可以继续调用方法 经验：在jQuery中，如果方法是设置的意思，返回的一般都是当前对象，就可以继续链式编程，获取值则一般不能继续 断链：对象调用方法之后，返回的已经不是当前的这个对象了，此时再调用方法就出现断链 解决方法：在断链的方法后面加.end()方法，此时不推荐使用链式编程，影响效率 类样式 $(\"#dv\").addClass(\"cls\");//为id为dv的元素添加cls类样式 $(\"#dv\").addClass(\"cls1\").addClass(\"cls2\");//为id为dv的元素添加多个cls类样式 $(\"#dv\").addClass(\"cls1 cls2\");//与上面效果的相同 $(\"#dv\").addClass();//返回的是该对象 //移除类样式 $(\"#dv\").removeClass(\"cls\");//移除多个的用法与上面的同 $(\"#dv\").removeClass();//返回的是该对象 //是否应用了类样式 $(\"#dv\").hasClass(\"cls cls2\"); //切换类样式 $(\"body\").toggleClass(\"cls\");//切换，事件触发，自动为body添加或删除cls。有则删，无则加 显示与隐藏 jQuery对象.show();//显示;参数1：毫秒;参数2：回调函数----动画执行完毕后执行 jQuery对象.hide();//隐藏;参数同上 // jQuery对象.slideDown();//下滑，显示;参数同上，效果类似卷帘门 jQuery对象.slideUp();//上滑，隐藏;参数同上 jQuery对象.slideToggle();//切换上滑和下滑，上两个的合并;参数同上 // jQuery对象.fadeIn();//淡入，显示;参数同上，大小不变，渐显 jQuery对象.fadeOut();//淡出，隐藏;参数同上 jQuery对象.fadeToggle();//切换淡入和淡出，上两个的合并;参数同上 jQuery对象.fadeTo();//更改透明度;参数1：时间毫秒(不可省)，参数2：透明度 动画 jQuery对象.animate();/* 参数1：css属性和值，json格式数据{\"width\":\"100px\",\"height\":\"200px\"} 参数2：时间（毫秒） 参数3：回调函数（可省） */ 元素的创建及添加 //jQuery父级元素.append(jQuery子级元素); $(\"#dv\").append($(\"百度\")); //创建一个子级元素直接加到父级元素 //jQuery子级元素.appendTo(jQuery父级元素); $(\"百度\").appendTo($(\"#dv\")); //注意：以上两种如果页面存在该元素，添加时相当于剪切，即原元素会消失 $(\"#dv>span\").clone().appendTo($(\"#dv1\")); //prepend $(\"#dv\").prepend($(\"this is span\"));//把创建的span标签这个子元素直接插入到id为dv的第一个子元素之前 $(\"this is span\").prependTo($(\"#dv\")); //after与before $(\"#dv\").after($(\"this is span\"));//创建一个兄弟元素，放在id为dv的后面 $(\"#dv\").before($(\"this is span\"));//创建一个兄弟元素，放在id为dv的前面 移除元素 $(\"#dv\").html(\"\");//移除id为dv的所有子元素 $(\"#dv\").empty();//清空id为dv的所有子元素 $(\"#dv\").remove();//删除自身 自定义属性 //html5 提倡自定义属性名为 data-xxx $(\"#dv\").attr(\"data-checked\");//获取自定义属性为checked值 //当用上述命名法后 原生写法 this.dataset['checked'] 省略data- //如果是data-foo-id这种时 this.dataset['fooId'];自动转换为驼峰命名法 //JQuery写法 $(\"#dv\").data(\"checked\") $(\"#dv\").attr(\"data-checked\",true);//设置自定义属性为checked值为true $(\"#dv\").removeAttr(\"data-checked\");//移除自定义属性为checked 设置或者获取元素选中 .prop(\"属性\",值);//值一般是布尔类型 .prop(\"属性\");//u获取是否选中 $(\"#ck1\").prop(\"checked\",true);//值一般是布尔类型,checked属性一般用这个设置 $(\"#j_tb :checked\");//获取id为j_tb内(有空格)有checked（勾上）的元素 $(\"#uu>li[index=1]\");//这是获取自定义属性为index=1的元素 设置宽、高、左距、右距、卷曲 .width();//获取宽，返回的是数字;括号里面可以是数字或带px的字符串 .height();//获取高 .offset();//返回一个对象{left:100,top:200},值是数字;也可以直接设置值;left包含left和margin-left .scrollLeft();//获取元素向左卷曲出去的距离，返回数字 .scrollTop();//获取元素向上卷曲出去的距离 为元素绑定事件 为同一元素绑定不同事件 //1、 $(\"#btn\").mouseenter(); $(\"#btn\").mouseleave(); $(\"#btn\").click(); //链式编程 $(\"#btn\").mouseenter().mouseleave().click(); //2、bind方法绑定 $(\"#btn\").bind(\"mouseenter\",function(){}); $(\"#btn\").bind(\"mouseleave\",function(){}); $(\"#btn\").bind(\"click\",function(){}); //bind链式编程 $(\"#btn\").bind(\"mouseenter\",function(){}).bind(\"mouseleave\",function(){}).bind(\"click\",function(){}); //bind 传入json $(\"#btn\").bind({\"mouseenter\":function(){},\"mouseleave\":function(){},\"click\":function(){}}); 为元素绑定相同事件 //1、 $(\"#btn\").click().click(); //2、 $(\"#btn\").bind(\"click\",function(){}).bind(\"click\",function(){}); //不能使用键值对，只会执行最后一个事件 为元素绑定事件的另一种方式 --- 事件委托 //父级元素调用方法，为子元素绑定事件 $(\"#dv\").delegate(\"p\",\"click\",function(){});//为id为dv的子元素p绑定点击事件 //on方法与delegate方法是一样的，参数顺序不同而已;delegate是调用on实现的 $(\"#dv\").on(\"click\",\"p\",function(){});//为id为dv的子元素p绑定点击事件 //多用于子元素动态创建 ，因此作为委托事件使用 tips: 第一种和bind方法不能为绑定事件后的元素绑定，而delegate方法和on方法可以为后面创建的元素绑定，建议以后直接用on方法 为元素解绑事件 解铃还需系铃人 解绑bind绑定的事件 //解绑bind 或者解绑$(\"#dv\").click()等绑定事件 $(\"#dv\").unbind(\"click\");//解绑所有的点击事件，可以解绑多个事件\"click mouseenter\" $(\"#dv\").unbind();//此时解绑所有事件 解绑delegate绑定的事件 //解绑delegate绑定的事件 $(\"#dv\").undelegate();//移除了id为dv的子元素所有的delegate方法绑定的事件 $(\"#dv\").undelegate(\"p\",\"click mouseenter\");//移除子元素p的点击和鼠标进入事件 解绑on绑定的事件 //解绑on绑定的事件 $(\"#dv\").off();//把父级元素和子级元素的所有事件全部解绑 $(\"#dv\").off(\"click mouseenter\");//把父级元素和子级元素的所有点击、鼠标进入事件全部解绑 $(\"#dv\").off(\"click mouseenter\",\"p\");//把子级元素p的所有点击、鼠标进入事件全部解绑 $(\"#dv\").off(\"\",\"p\");//把子级元素p的所有事件全部解绑 $(\"#dv\").off(\"click\",\"**\");//把所有子级元素的所有点击事件全部解绑 事件冒泡 多个标签嵌套，如果注册相同的事件，会产生事件冒泡 阻止事件冒泡 $(\"#dv\").click(function (){ console.log(\"hello\"); return false;//在想要阻止的那一层添加此方法即可，可兼容其他浏览器 }); 事件的触发 //1、 $(\"#btn\").click(function (){ $(\"#txt\").focus();//点击id为btn的按钮，让id为txt的文本框获取焦点事件发生 }); //2、 $(\"#btn\").click(function (){ $(\"#txt\").trigger(\"focus\");//点击id为btn的按钮，让id为txt的文本框获取焦点事件发生 }); //3、 $(\"#btn\").click(function (){ $(\"#txt\").triggerHandler(\"focus\");//直接执行focus的处理函数;可以触发事件，但不能触发浏览器的默认行为 }); 便历jQuery对象 //使用each方法，遍历ul内所有的li $(\"#uu>li\").each(function (index,ele) {//是一个伪数组，可以通过索引获得其中的元素 var opacity=(index+1)/10; $(ele).css(\"opacity\",opacity);//注意ele是DOM对象，要先转化 }) }); 多库共存 多个jQuery库引用，$会冲突 1、$被占用时，可以使用jQuery来代替 2、var xy=$.noConflict();//把$的权利给了xy，$就可以作为其他的用法出现在代码中 包装集 把很多的DOM的对象进行包装或者是封装------>jQuery对象 jQuery对象------->jQuery对象[0]----------->获取到这个对象 如果jQuery获取的是多个对象，可以改变索引 $(function (){ $(\"p\")[1]innerText;//获取第二个p标签 }); 判断对象是否存在 $(\"#btn\").length==0;//等于0则代表存在 if($(\"#btn\")){};//这个方法不行，btnsdsa这种如果有，则会返回true 宽高属性 .innerWidth();//返回元素的宽度（不包括边框） .innerHeight();//返回元素的高度（不包括边框） .outerWidth();//返回元素的宽度（包括边框）;q里面填true 或false 与不填结果一样 .outerHeight();//返回元素的高度（包括边框） 插件 就是一个功能，别人把功能写好了，直接那过来就可以用了 自己做插件 //如果希望jQuery的对象能调用这个方法，就把这个方法加入到$.fn中 $.fn.functionName=function (){}; 引用别人的插件 引入css文件 jQuery的js文件，插件的js文件 复制html代码到body中 复制实现基本功能的代码到页面加载的事件中 $.fn 事件参数对象下的几个属性 //用于事件冒泡的调试 e.target;//这个属性得到的是触发该事件的目标对象，是DOM对象;点击的目标 e.currentTarget;//得到的是触发该事件的当前对象，是DOM对象;由于事件冒泡也发生点击事件的对象 e.delegateTarget;//得到的是代理的这个对象，是DOM对象 jQuery UI jQuery的用户界面 引入方法类似上面的引用插件方法 mouseenter和mouseover的区别 不论鼠标指针穿过被选元素或其子元素，都会触发mouseover事件 mouseover：会有事件冒泡，进入子元素也会触发一次 mouseenter：只有鼠标进入本元素才会触发 "},"JavaScript/demos.html":{"url":"JavaScript/demos.html","title":"JavaScript 样例","keywords":"","body":"textarea 自动调整高度 $('#textarea').on('input',function () { // 最小高度 var minRows = 2; // 最大高度，超过则出现滚动条 var maxRows = 5; if (this.scrollTop == 0) { this.scrollTop = 1 } while (this.scrollTop == 0) { if (this.rows > minRows){ this.rows-- }else{ break } this.scrollTop = 1 if (this.rows 0){ this.rows++; break; } } while(this.scrollTop > 0){ if (this.rows 注册 被 vue 动态渲染(生成) 及 后面生成的 DOM 元素 // 解决 ：点击展开 DOM 树之后 才可以绑定上事件 $(document).on('click', '.selectCate', function() { console.log('123') }) jquery 点击元素以外任意地方隐藏该元素 // 第一先实现点击任何地方都隐藏该元素(假设id=\"bar\") $(document).click(function(){ $(\"#bar\").hide(); }); // 那么bar也属于document，点击bar也会让自己隐藏，显然这不是想要的，这时候要阻止冒泡事件，即document的事件对bar无效 $(\"#bar\").click(function(event){ event.stopPropagation(); }); FormData 选择文件 上传 new Vue({ methods:{ postMultiGift(){ let formData = new FormData() formData.append('file',$('#file')[0].files[0]) axios({ method: 'post', url: './batch_activity_order', data: formData, headers:{'Content-Type':'multipart/form-data'} }).then(function(response){ const res = response.data // console.log(res) }) } } }) ios关闭软键盘页面不回弹 $('input,textarea').on('blur',function(){ window.scroll(0,0) // 或者 let scrollHeight = document.documentElement.scrollTop || document.body.scrollTop || 0 window.scrollTo(0, Math.max(scrollHeight - 1, 0)) }) $('select').on('change',function(){ window.scroll(0,0) }) iOS 微信 视频自动播放 | 视频不全屏 \" controls=\"controls\" autoplay width=\"100%\" @ended=\"videoEnd\" webkit-playsinline=\"true\" playsinline x5-video-player-type=\"h5\" x-webkit-airplay=\"true\"> // 一般情况下，这样就可以自动播放了，但是一些奇葩iPhone机不可以 $('.swiper-slide video')[0].play() // iOS 必须在微信Weixin JSAPI的WeixinJSBridgeReady才能生效 document.addEventListener(\"WeixinJSBridgeReady\", function () { $('.swiper-slide video')[0].play() }, false) 导出 excel JavaScript生成 CSV 文件 data:[][;base64], data:是前缀 mediatype: 文件的MIME类型，比如image/jpge对应JPGE文件，默认值为text/plain;charset=US-ASCII base64: 文件内容是否base64格式的 data: 文件的正文内容 // \\uFEFF 解决中文乱码问题 // download 自定义文件名 H5 var a = document.createElement('a'); a.href=`data:text/csv;charset=utf-8,\\uFEFF${encodeURI('姓名,年龄\\nMofei,18')}`; a.download=\"Mofei的CSV.csv\"; a.click(); "},"Vue/":{"url":"Vue/","title":"Vue","keywords":"","body":"VUE VUE 基础 VUE 高级 VUE 样例 "},"Vue/base.html":{"url":"Vue/base.html","title":"Vue 基础","keywords":"","body":"单页面应用程序 Single Page Application (SPA) 一个网站就一个页面 极致的用户体验，就像 native app 一样 优点： 分离前后端关注点，前端负责界面显示，后端负责数据存储和计算 缺点： 不利于 SEO，搜索引擎优化 简单模拟单页面应用程序的效果 hash window.onhashchange 事件 当 hash 改变时，根据不同的 hash 做不同的处理 发现音乐 我的音乐 朋友 // 这里我们通过注册 window.onhashchange 事件来监听 hahs（锚点）的改变 // 我们的 url 地址发生改变了 // 改变之后我们就解析 hash 中的路径标识 // 然后根据不同的路径标识渲染不同的页面到单页面中的容器中 window.onhashchange = function () { var hash = window.location.hash.substr(1); // #/ if (hash === \"/\") { $.get(\"./find-music.html\", function (data) { $(\"#container\").html(data); }); } else if (hash === \"/my-music\") { $.get(\"./my-music.html\", function (data) { $(\"#container\").html(data); }); } }; MVVM 架构模式 核心思想：数据驱动视图 这种模式最大的好处是解耦，数据和视图不再是强耦合在一起 好处： 低耦合 可重用性 独立开发 可测试性 字面意义： M：Model 业务数据模型，和视图没有关系 V：View 视图 VM： ViewModel 视图数据模型，视图数据 数据绑定原理（VM 原理） 设计模式：事件观察者（发布/订阅模式） function EventEmit() { this.callbacks = {}; } EventEmit.prototype.on = function (eventName, eventFun) { if (!this.callbacks[eventName]) { this.callbacks[eventName] = []; } this.callbacks[eventName].push(eventFun); }; EventEmit.prototype.emit = function (eventName) { if (!this.callbacks[eventName]) { return; } this.callbacks[eventName].forEach((fn) => { fn(); }); }; Object.defineProperty() 高级属性定义方式 // 允许精确添加或修改对象的属性，默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的。 var o = { b: \"\" }; // 创建一个新对象 // 参数1：该对象 参数2：属性（要更改|添加属性） 参数3：方法 Object.defineProperty(o, \"b\", { get: function () { // 当访问该属性时，该方法会被执行，方法执行时没有参数传入 return bValue; }, set: function (newValue) { // 当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。 bValue = newValue; }, }); 所有关心 message 改变的 DOM 都订阅了 message 事件 当 message 改变时，就发布 message 事件 Vue 基础 安装： npm i vue Vue 实例: el 表明被 Vue 管理的模板入口，网页中的 DOM 节点 不能使用 body、html 必须是一个普通的 HTML 标签节点，一般是 div data 作用：数据驱动图 中的 数据 不是什么数据都往里面初始化的 只需要在 data 中初始化一个数据成员，然后在模板中绑定使用这个成员 核心就是把 DOM 操作的思想转变到 数据驱动视图 的思想 methods 作用：一般是用来定义事件处理函数 虽然我们可以把方法写到 data 中，但是在 Vue 中更推荐把所有方法都写到 methods 属性中 不允许具有和 data 中重名的成员 computed 称作 计算属性，在模板中绑定多次，当相关的数据发生变化，只会执行一次，缓存计算结果 从代码上看是一个方法，但是只能当作属性来使用 计算属性与方法的区别（返回结果用于模板绑定）： 都可以达到相同的效果 如果是方法，则一旦方法所在的视图发生变化，则方法一定会重复执行 方法没有缓存，也就是是说多次使用该方法，则会重复执行 计算属性是整正依赖与内部 data 中的数据，如果数据没变，则计算属性不会重复执行 所以相比来说，计算属性要比方法更为高效 {{ message }} {{ say() }} {{ num }} const app = new Vue({ // 规定不能作用到 body 和 html 节点上 el: \"#app\", data: { message: \"Hello Vue.js!\", }, methods: { say() { return \"hello\"; }, }, computed: { num() { return 1 + 2; }, }, }); 简单总结： jQuery 提高了 DOM 操作的效率 Vue 极大的解放了 DOM 操作（Vue 全部把 DOM 操作都给你屏蔽了） Vue 的核心思想就是：数据驱动视图（MVVM） 还有一点就是 Vue 其实是一个更高级的模板引擎 在 Vue 中，通过模板绑定的数据都是响应式的 数据如果一旦变化，则绑定该数据的视图元素也会变化 数据绑定渲染 文本绑定： {{}} 或 v-text:data 中的数据成员名 属性绑定：v-bind:属性名称=\"JavaScript 表达式\" 简写： :属性名称=\"表达式\" v-bind:class=\"{类名: 布尔值}\" 当布尔值为 true 时，则作用这个类名 当布尔值为 false 时，则去除这个类名 数据单向绑定 数据变，视图变 视图变，数据不会变 使用 JavaScript 表达式： {{ number +1 }} {{ ok ? 'yes' : 'no' }} {{ message.split('').reverse().join('') }} 模板语法 计算属性和观察者 计算属性用于需要在模板中绑定输出值 而 watch 观察者则用于需要根据数据的改变，从而定制特殊功能业务 watch 只是监视，不返回数据，而且只能观察自己的 data 成员 不是用于模板绑定的 Class 与 Style 条件渲染 v-if v-else v-else 元素必须紧跟在带 v-if 或 v-else-if 的元素之后 v-if 和 v-else-if 类似与 v-else ，v-else-if 也必须紧跟在带 v-if 或 v-else-if 的元素之后 v-show v-show 只是简单的切换元素的 CSS 属性 display v-show 不支持 元素，也不支持 v-else v-if 和 v-show 的区别 v-if 是“真正”的条件渲染，条件为真则渲染，条件为假则移除 DOM 元素 v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换 v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销 因此，如果需要非常频繁的切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好 列表循环渲染 v-for=\"item in items\" v-for=\"(item,index) in items\" v-for=\"item of items\" 可以用 of 替代 in 作为分隔符，因为他是最接近 JavaScript 迭代器的语法 对象迭代 v-for=\"value in object\" `v-for=\"(value,key) in object\" v-for=\"(value,key,index) in object 数组更新检测 对象更新检测 {{ item }} const app = new Vue({ el: \"#app\", data: { fruits: [\"apple\", \"orange\", \"banana\"], }, }); 事件处理 定义事件处理函数 点击+1 --> {{ number }} 点击+1 const app = new Vue({ el: \"#app\", data: { number: 1, }, // 注意：方法写到 data 中可以，但是函数内部的 this 是 Window // 所以我们都建议把方法写到 methods 选项中 methods: { handleIncrement: function () { // 在通过 v-on 注册的方法中我们可以直接通过 this 来访问 data 中的数据成员 this === app 这个对象 this.number++; }, }, }); 绑定事件处理函数 v-on:事件名称=\"事件 处理函数\" 简写： @事件名称=\"事件 处理函数 访问原声 DOM 事件，可以使用特殊变量 $event 把它传入方法 Submit // ... method:{ clickHandler (message,event){ ... } } 表单输入绑定 表单 数据双向绑定 v-model=\" data 中的数据成员名\" v-model 是 Vue 提供的一个特殊的属性，在 Vue 中被称之为指令 它的作用就是：双向绑定表单控件 什么是叫双向数据绑定？ 当数据发生改变， DOM 会自动更新 当表单控件的值发生改变，数据也会自动得到更新 双向数据绑定 数据变化 视图变化 相互影响 文本 多行文本 复选框 单选按钮 选择列表 普通元素模拟数据双向绑定 export default { data() { return { content: \"\", }; }, methods: { handleInput($event) { this.content = $event.target.innerText; // 拓展 如果想要只需要前100位数据 this.content = this.content.substring(0, 100); }, }, }; 组件 组件概念 使用组件 在模板使用时基于驼峰命名法，转为小写，用 - 拼接 component 时，可以使用驼峰命名法 全局组件（通用组件） 我们一般把网页中特殊的反而公共部分注册为全局组件：轮播图、tab 选项卡、分页、通用导航 创建组件构造器（直接注册，可省略） let Profile = Vue.extend({ // 模板选项 template: `hello`, }); 注册 // 全局 参数1：组件名称 参数2：构造器名 Vue.component(\"my-component\", Profile); // 简写方式 将 Profile 替换成 { template:`...`} Vue.component(\"my-component\", { template: `hello`, }); 使用：挂载作用域下实例化 局部组件（子组件） 局部组件注册一般是注册一些非通用，只适用于当前项目的 注册： var Child = { template: `hello`, }; new Vue({ // ... components: { // 将只在父组件模板中可用 \"my-component\": Child, }, }); 使用： 组件与组件之间是相互独立的 默认情况下，组件与组件之间无法进行跨组件数据访问，父子组件也不行 组件就是一种特殊的 Vue 实例，不需实例化，它管理自己的 template 在组件中，也可以配置自己的类似于 Vue 实例的一些选项资源：data、methods、computed 思想：组件管理自己，不影响别人 组件的 data 选项必须是函数 组件的 data 必须是函数（手动 new 出来的 Vue 实例才是普通对象） 函数内部返回一个对象 Vue.component(\"my-div\", { template: \"#my-template\", data: function () { return { counter: 0 }; }, }); // 原因：由于自定义组件可以使用多次，data返回的函数则说明函数内部变量是局部变量（组件之间不会相互影响） template 标签 hello world Vue.component(\"my-div\", { template: \"#my-template\", }); new Vue({ el: \"#app\", }); script 标签 hello world 使用组件注意事项 组件可以理解为特殊的 Vue 实例，管理自己的 template 模板 组件的 template 必须有且只有一个根节点 组件与组件之间是相互独立的，可以有自己的 data、methods、computed。。。 组件的 data 必须是函数 父子组件 // 子组件构造器 let Child1 = Vue.extend({ template: `i am child1`, }); let Child2 = Vue.extend({ template: `i am child2`, }); // 父组件构造器 Vue.component(\"parent\", { components: { child1: Child1, child2: Child2, }, template: ``, // 在模板中不能使用 ，它只在父组件构造器中有用，要在外部使用需注册 }); 父子组件间的通信：props down 父组件要给子组件传递数据，子组件需要将它内部发生的事件告知给父组件 (props down,events up ) 父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息 父组件给子组件传递数据通过 props 来传递： 先在父组件中往子组件标签上添加动态属性（v-bind）来传递数据 然后在子组件中声明 props 来接收父组件传递的数据 然后在子组件中就可以直接通过 this 来访问 props 中的数据了 Vue.component('my-parent', { template: '#my_parent', props: ['imgtitle'], // 注册子组件 components: { 'child1': { template: '{{title}}', // 使用 props 获取父组件传递的数据 props: ['title'] }, } }) new Vue({ el: '#app', data: { title: 'hello', }, }) 单向数据流 props 是单向绑定的，父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改父组件的状态，来避免应用的数据流变得难以理解 另外，每次父组件更新时，子组件的所以 props 都会更新为最新值 如果只想拿到一次父组件给的数据，而不想受父组件影响 props: ['initialCounter'], data: function () { return { counter: this.initialCounter } } Prop 验证 建议，声明 props 都使用验证的方式 Vue.component('my-component', { props: { // 带有默认值的数字 propD: { type: Number, default: 100 }, } } 父子组件间的通信：Events Up 子组件在内部通过 this.$emit(自定义事件名称[,可选参数]) 发布事件 父组件在使用子组件的标签上通过 @自定义事件名称=\"事件处理函数\" 的方式来订阅子组件内部发布的事件 这样的话，当子组件内部 this.$emit 时，则父组件订阅的自定义事件就会执行 一共点击了{{total}} Vue.component('num', { template: '{{ count }}', data: function () { return { count: 0, } }, methods: { counter() { this.count += 1 return this.$emit('counter',this.count1,this.count2) // 通过给父组件传递 已触发 counter自定义事件 来传递数据 } } }) new Vue({ el: '#app', data: { total: 0, }, methods: { allCount() { this.total += 1 } } }) 使用插槽分发组件内容 动态组件 组件其他 进入/离开 & 列表过渡 组件的切换使用 component 标签的 is 属性来完成组件动态绑定 按钮的@click 来修改 data 属性从而切换组件 keep-alive 标签来保留组件的状态值 第一项 第二项 第三项 var Vue = new Vue({ el:'#app', data:{ nowHeader:'header-1' } components:{ 'header-1':{template:`组件1`}, 'header-2':{template:`组件2`}, 'header-3':{template:`组件3`} }, methods:{ changeComp(index){ this.nowHeader='header-'+index } } }) Vue 指令 系统内置指令 v-text 和 {{}} 一样，唯一的区别是 {{}} 会闪烁，v-text 不会有闪烁 如果想用 {{}} 又不想闪烁，可以使用 v-cloak v-html 更新元素的 innerHTMl，即 可插入带 html 标签的字符串 v-show 通过控制 display: none|block; ，条件显示和隐藏 如果需要频繁的切换显示和隐藏，则使用 v-show v-if 真正的条件渲染 条件为真，则渲染；条件为假，则移除不渲染 如果只是一次显示和隐藏，则建议 v-if v-else v-else-if v-for v-on v-bind v-model v-slot v-pre Vue 不处理 带有 v-pre 指令的 DOM 元素 用于提高性能 {{ message }} v-cloak 需在头部加载一个特殊样式：[v-cloak] {display: none;} 然后在被 Vue 管理的模板入口节点上作用 ： v-cloak 指令 原理：默认一开始被 Vue 管理的模板是隐藏的，当 Vue 解析处理完 Vue 模板之后，会自动把这个样式去除，然后就显示出来 v-once 只绑定渲染一次，以后数据再变，也不会影响该内容 {{ message }} 自定义指令 在需要对普通 DOM 元素进行底层操作时，就会用到自定义指令。 注册绑定方式 指令的名字 名字中不要加 v- 前缀（只有使用时才加） 如果有多个单词，则建议使用驼峰命名法 在使用时，首先要加 v- 前缀，然后基于驼峰命名法，转为小写，用 - 拼接 全局注册 Vue.directive('指令名称',{配置参数}) 如果是全局指令，则一定要在实例化 Vue 之前注册 全局指令在所有组件(实例)中都可以使用 如果需要在任何组件中可能使用的指令，把其注册成全局指令 局部注册 通过实例选项 directives 来注册 指令的名字作为 directives 对象的成员 局部自定义指令只能在这个组件（实例）中使用 如果只是在某个组件中使用，这个时候注册为组件内局部指令 举个聚焦输入框的例子，如下： // 注册一个全局自定义指令 `v-focus` // 第一个参数 指令名称，使用时需加上 v- 前缀 Vue.directive(\"focus\", { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el为 在模板中使用 v-focus 指令的 DOM 元素 el.focus(); }, }); // 简写方式，自动应用到 binding 和 update 两钩子函数 Vue.directive(\"focus\", function (el) { el.focus(); }); 在模板中使用 指令的生命钩子函数 bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数参数 el 作用该指令的 DOM 元素 binding value 指令的值 服务端通信 Vue 没有内置任何 ajax 请求方法 在 Vue 1.0 时代，大家都使用一个插件： vue resource 来发送请求 支持 Promise 在 Vue 2.0 时代，大家都选择社区中第三方库：axios 支持 Peomise 在 HTML5 时代，后来浏览器增加了一个特殊的异步请求方法 ：fetch （原生支持 Promise） 由于兼容性问题，一般只在移动端使用 甚至你可能会在一些别人的项目看到 Vue 和 jQuery 混用的情况 结合生命钩子获取数据，渲染数据，一般在 created 阶段使用 生命周期钩子 beforeCreate Vue 实例化之后调用；数据观测（data observer）和 event/watcher 事件配置之前 $data 、$el 不可见 created 在实例创建完成之后调用，已完成：数据观测（data observer），属性和方法的运算，watch/event 事件回调， $data 可见（但是模板还没得到更新），$el 不可见 由于模板还未得到更新，所以无法通过 DOM 操作得到更新之后的结果 适用于 发送请求，修改 data 数据 beforeMount 在挂载元素之前被调用：相关的 render 函数首次被调用，还没有渲染 DOM $el 可见，模板还是未更新 如果在实例化时 没有 el:'#app' 则调用 new Vue({...}).$mount('#app') 两个方式等价 mounted 挂载渲染已完成，DOM 数据已更新 如果想 DOM 操作，可在这里进行 beforeUpdate 数据更新前调用， DOM 还没得到更新 updated 数据更新之后调用， DOM 已得到更新 activated keep-alive 组件激活时调用 deactivated keep-alive 组件停用时调用 beforeDestroy Vue 实例销毁之前 destroyed Vue 实例销毁之后，销毁不是删除实例，而是不再管理 app.$destroy() 完全销毁一个实例，清理它与实例的连接，解绑指令及事件监听器 errorCaptured 捕获组件中发生的错误 crumbs v-for 多层数据 再套用 v-for 字符串转 html {{item.content}} methods 中一个方法调用另一个方法 methods: { test1:function(){ alert(this.test) }, test2:function(){ alert(\"this is test2\") alert(this.test) //test3调用时弹出undefined }, test3:function(){ this.$options.methods.test2();//在test3中调用test2的方法 } } # 项目结构 . ├── index.html ├── main.js ├── api │ ├── ... #抽取出 API 请求 ├── components ├── index.js # 我们组装模块并导出 store 的地方 ├── action.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 // vue渲染完成 this.$nextTick(() => { this.show = false; }); "},"Vue/advanced/":{"url":"Vue/advanced/","title":"Vue 高级","keywords":"","body":"Vue 本章主要介绍两个方面的内容： Vue-axios Vue-router Vuex "},"Vue/advanced/Vue-axios.html":{"url":"Vue/advanced/Vue-axios.html","title":"Vue-axios","keywords":"","body":"起步 安装： # vue-axios 依赖 axios npm install --save axios vue-axios vuecli3 配置 vue-axios 提示：使用插件的时候，一般都要在入口文件main.js中引入，因为main.js项目运行首先运行的文件。 // main.js import Vue from 'vue' import axios from 'axios' import VueAxios from 'vue-axios' Vue.use(VueAxios, axios) 疑问：为什么使用Vue.use(VueAxios, axios) 解惑：通过全局方法 Vue.use() 使用插件，就相当于调用install方法，vue官网举例如下： // 调用 'MyPlugin.install(Vue)' Vue.use(MyPlugin) 使用： Vue.axios.get(api).then((response) => { console.log(response.data) }) this.axios.get(api).then((response) => { console.log(response.data) }) this.$http.get(api).then((response) => { console.log(response.data) }) // 使用 axios 不是 vue-axios axios.post( \"/task_manage/task\", { sddsdf: \"sdfd\" }, { headers: { \"Content-type\": \"application/x-www-form-urlencoded\" }//没有 headers 不是 post 请求？？？？ } ).then(res => { this.taskInfo = res.data.data; console.log(res.data.data); }); vue-axios学习网址 https://blog.csdn.net/qq_41115965/article/details/80780264 网址1： https://github.com/imcvampire/vue-axios 网址2： https://www.npmjs.com/packge/axios 本地跨域 devServer: { port: 8080, proxy: { '/task_manage': { target: 'http://localhost:80/ztong/manual.php/task_manage/task', // target host 接口地址 80 是接口端口 ws: true, // proxy websockets changeOrigin: true, // needed for virtual hosted sites pathRewrite: { '^/task_manage': '' // rewrite path } } } } axios 发 post 请求，后端接收不到参数的解决方案 axios会帮我们 转换请求数据和响应数据 以及 自动转换 JSON 数据 就是说，我们的 Content-Type 变成了 application/json;charset=utf-8 然后，因为我们的参数是 JSON 对象，axios 帮我们做了一个 stringify 的处理。 而且查阅 axios 文档可以知道：axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的。 那么，这就与我们服务端要求的 'Content-Type': 'application/x-www-form-urlencoded' 以及 @RequestParam 不符合。 解决方案： //用 URLSearchParams 传递参数】 let param = new URLSearchParams() param.append('username', 'admin') param.append('pwd', 'admin') axios({ method: 'post', url: '/api/lockServer/search', data: param }) // 发送 get function sendGetAxios(url,params,fun) { axios({ method:'get', url: url, params: params }).then(function (res) { fun && fun(res) }) } // 发送 post function sendPostAxios(url,params,fun) { let data = new URLSearchParams() for (para in params) { data.append(para, params[para]) } axios({ method:'post', url: url, data: data, headers: {\"Content-type\": \"application/x-www-form-urlencoded\"} }).then(function (res) { fun && fun(res) }) } 原文：https://blog.csdn.net/csdn_yudong/article/details/79668655 jQuery.ajax的post提交默认的请求头的Content-Type: application/x-www-form-urlencoded 而axios.post提交的请求头是Content-Type: application/json。 application/json是一个趋势，但是如果改一个旧项目，把jQuery.ajax全部换成axios.post时，需要对请求做一些配置 // 原来的代码 没有指定请求头的content-type var data = {age: 18}; $.ajax({ url: '', type: 'POST', data: data dataType: 'json', success: function(result) { // do something } }) // 使用 axios 的代码 import axios from 'axios'; import qs from 'qs'; var data = {age: 18}; var url = ''; axios.post( url, qs.stringify(data), {headers: {'Content-Type': 'application/x-www-form-urlencoded'}} ).then(result => { // do something }) 下载文件 axios({ method:'post', url: downloadFileUrl, data: data, headers: {\"Content-type\": \"application/x-www-form-urlencoded\"}, responseType:'blob' }).then( (res) =>{ let blob = new Blob([res.data]) let downloadElement = document.createElement('a') let href = window.URL.createObjectURL(blob); //创建下载的链接 downloadElement.href = href; downloadElement.download = `商品列表.xls`; //下载后文件名 document.body.appendChild(downloadElement); downloadElement.click(); //点击下载 document.body.removeChild(downloadElement); //下载完成移除元素 window.URL.revokeObjectURL(href); //释放blob对象 }) chunk 数据处理 // 设置 responseType responseType: \"arraybuffer\" // 处理 arraybuffer let imgBase64; const resolve = res => { imgBase64 = \"data:image/png;base64,\" + btoa( // 将图片数据做处理(百度的) new Uint8Array(res).reduce( (data, byte) => data + String.fromCharCode(byte), \"\" ) ); return imgBase64 }; await jobManageImageApi.getImage(id).then(resolve); "},"Vue/advanced/Vue-router.html":{"url":"Vue/advanced/Vue-router.html","title":"Vue-router","keywords":"","body":"起步 安装： npm install vue-router 配置： 非模块化工程 直接引入 在模块化工程使用时 使用 Vue.use() import Vue from \"vue\"; import VueRouter from \"vue-router\"; Vue.use(VueRouter); 实例 在页面中通过 声明路由的出口 new VueRouter({}) 通过 routers 选项配置路由表，当请求 xxx 时，渲染指定组件 在 Vue 实例中，通过选项 router 配置路由实例，从而让整个应用具有路由能力 Hello App! Go to Foo 等效下面的--> Go to Foo Go to Bar // 1. 定义 (路由) 组件。 // 可以从其他文件 import 进来 const Foo = { template: \"foo\" }; const Bar = { template: \"bar\" }; // 2. 定义路由 // 每个路由应该映射一个组件。 其中\"component\" 可以是 // 通过 Vue.extend() 创建的组件构造器， // 或者，只是一个组件配置对象。 const routes = [ { path: \"/foo\", component: Foo }, { path: \"/bar\", component: Bar }, ]; // 3. 创建 router 实例，然后传 `routes` 配置 const router = new VueRouter({ routes, // (缩写) 相当于 routes: routes }); // 4. 创建和挂载根实例。 // 记得要通过 router 配置参数注入路由， // 从而让整个应用都有路由功能 const app = new Vue({ router, }).$mount(\"#app\"); 配置链接激活时使用的 CSS 类名 const router = new VueRouter({ linkActiveClass: \"active\", // 当链接激活时，获得的 CSS 属性是 active routes: [ { path: \"/\", component: Home, // 没有 's' ！ }, ], }); Home 导航守卫 beforeRouteUpdate 主要用来通过跳转或取消的方式守卫导航，自动在导航到该组件之前调用 to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push中的选项。 next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError()注册过的回调。 确保要调用 next 方法，否则钩子就不会被 resolved。 没有 next() 路由过不来 export default { data() { return { list: [], }; }, async beforeRouteUpdate(to, from, next) { // ... next((vm) => { // 通过 `vm` 访问组件实例 // 注意：不！能！获取组件实例 `this`,也不能获得 methods 的函数 // 所以不能调用 methods 的函数 }); }, }; beforeRouteLeave // 路由跳转前 在子组件内 判断跳转到其他路由前 window.ApiAdd = { template, data: function () { return {}; }, // 判断是否有 api_id beforeRouteLeave(to, from, next) { if (this.api_id) { var query = to.query; // 需要声明一个 query 对象 query.api_id = this.api_id; next({ query: query, }); } else { layer.msg(\"请先添加完接口\"); next(false); } }, }; 路由传参 User router.push({ name: \"user\", params: { userId: 123 } }); crumbs 在配置好 vue.router 之后，会自动在 vue 组件添加 $router 和 $route this.$router 访问得到的是 路由实例 对象 this.$route 访问到的是 路由参数 对象 this.$router.query 获取查询字符串参数 "},"Vue/advanced/Vuex.html":{"url":"Vue/advanced/Vuex.html","title":"Vuex","keywords":"","body":" {% raw %} const counter = { template: ` 点击数量：{{count}} 用户名：{{name}} `, computed:{ count(){ return this.$store.state.count }, name(){ return this.$store.state.name }, userName(){ return this.$store.getters.userName } } } const store = new Vuex.Store({ state:{ // 定义状态，相当于 data count:10, name:'jack' }, getters:{ // 与 state 一样是 状态，相当与 computed userName(state){ // 通过 store.getters.userName 调用 return state.name + ',Hello' }， getTodoById: (state) => (id) => { // 也可以返回一个函数，通过 store.getters.getTodoById(2) 调用 return state.todos.find(todo => todo.id === id) } }, mutations:{ // 更改 state 内的值，只能同步操作 通过 this.$store.commit('increment',5) increment(state,num){ state.count = num }, updateName(state,userName){ state.name = userName } }, actions:{ // 触发 mutations 的函数，可异步操作 通过 this.$store.dispatch('incrementAction',5) 触发 incrementAction(context,num){ context.commit('increment',num) } } }) new Vue({ el:\"#app\", store, components:{ counter }, methods:{ add(){ this.$store.commit('increment',5) // 触发 mutations 的函数 this.$store.dispatch('incrementAction',5) // 触发 actions 的函数 } } }) {% endraw %} "},"Vue/demos.html":{"url":"Vue/demos.html","title":"Vue 样例","keywords":"","body":"递归渲染 {% raw %} // 递归组件 ;(function () { const template= `{% endraw %} {{title}} {% endraw %} ` window.TreeMenu = { name: 'tree-menu', template, props: [ 'title', 'tree','id' ], data(){ return { showChildren:false } }, methods: { toggleChildren() { this.showChildren = !this.showChildren; }, selectCate(id){ console.log(id) } } } })() new Vue({ data:{ cateList:[{ id: \"221\", pid: \"0\", title: \"服饰箱包\", tree: { id: \"207\", pid: \"221\", title: \"箱包 } }] }, components: { TreeMenu } }) 上传 多张图片 * 背景图片 未选择文件仅支持jpg、jpeg、png格式的图片 ADDbTN.png\" width=\"65\" height=\"65\" @click.prevent=\"addPic\" /> 0\"> 移除全部图片 上传 .bgImgList ul { padding: 0; margin: 0; } .bgImgList li { float: left; margin-right: 15px; position: relative; padding: 5px; background-color: #ccc; } .bgImgList li:last-child { padding: initial; background-color: initial; } .bgImgList li a { position: absolute; top: -8px; right: -8px; } const activityEdit = new Vue({ el: \"#activityEdit\", data: { id: \"\", bgPreImg: [], bgImgFiles: [], bg_pic: [], }, methods: { init() { // 获取 活动分类 sendPostAxios(activityTypeUrl, {}, (response) => { const res = response.data; this.activityType = res.data; }); }, addPic(event) { $(event.currentTarget).next(\"input[type=file]\").trigger(\"click\"); return false; }, onFileChange(e) { let files = e.target.files || e.dataTransfer.files; if (!files.length) return; this.bgImgFiles = files; this.createImage(files); }, createImage(file) { if (typeof FileReader === \"undefined\") { layer.msg(\"您的浏览器不支持图片上传，请升级您的浏览器\"); return false; } const leng = file.length; for (var i = 0; i { this.bgPreImg.push(e.target.result); }; } }, delImage: function (index) { if (this.bg_pic.length > 0) { this.bg_pic.splice(index, 1); } this.bgPreImg.splice(index, 1); }, removeImage: function (e) { this.bgPreImg = []; this.bg_pic = []; }, uploadImage: function () { let sucNum = 0; let retNum = 0; for (let i = 0; i { const res = response.data; console.log(res); retNum++; if (res.status == 0) { this.bg_pic.push(res.data); sucNum++; } if (retNum { const res = response.data; // 背景图片 this.bg_pic = res.data.bg_pic.split(\",\"); this.bgPreImg = res.data.bg_pic.split(\",\"); }); }, }); vue data 恢复初始化数据 // 重置表单 this.form = this.$options.data().form; Object.assign(this.$data, this.$options.data()); 时间戳转换 export default { filters: { timeFilter(time) { const date = new Date(time); const Y = date.getFullYear(); const M = date.getMonth() + 1 校验 // 验证纯英文 const validateEnglish = (rule, value, callback) => { const reg = /^[a-zA-Z]+$/; if (!reg.test(value)) { callback(new Error(\"仅支持字母组合\")); } else { callback(); } }; // 验证纯中文 const validateChinese = (rule, value, callback) => { const reg = /^[\\u4e00-\\u9fa5]+$/; if (!reg.test(value)) { callback(new Error(\"只能输入中文\")); } else { callback(); } }; // 校验中文名称重复 const validateDuplicate = async (rule, value, callback) => { const params = { category: \"system\", name: value, parentId: this.parentNode.id, id: this.form.id || \"\", }; const res = await dataCatalogApi.exist(params); const { code, object, msg, errorMsg } = res; if (code === 0) { if (object) { callback(new Error(\"名称重复\")); } else { callback(); } } else { this.$notify({ title: \"错误\", message: errorMsg || msg, type: \"error\", }); callback(new Error(\"校验失败\")); } }; "},"nodejs/":{"url":"nodejs/","title":"nodejs","keywords":"","body":"nodejs nodejs 基础 nodejs API "},"nodejs/base.html":{"url":"nodejs/base.html","title":"nodejs 基础","keywords":"","body":"Node.js 是什么 JavaScript 运行时 既不是语言，也不是框架，它是一个平台 Node.js 中的 JavaScript 没有 BOM、DOM EcmaScript 基本的 JavaScript 语言部分 在 Node 中为 JavaScript 提供了一些服务器级别的 API 文件操作的能力 http 服务的能力 《深入浅出Node.js》 Node 中的 JavaScript EcmaScript 变量 方法 数据类型 内置对象 Array Object Date Math 模块系统 在 Node 中没有全局作用域的概念 在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件 require 加载只能是执行其中的代码，文件与文件之间由于是模块作用域，所以不会有污染的问题 模块完全是封闭的 外部无法访问内部 内部也无法访问外部 模块作用域固然带来了一些好处，可以加载执行多个文件，可以完全避免变量命名冲突污染的问题 但是某些情况下，模块与模块是需要进行通信的 在每个模块中，都提供了一个对象：exports 该对象默认是一个空对象 你要做的就是把需要被外部访问使用的成员手动的挂载到 exports 接口对象中 然后谁来 require 这个模块，谁就可以得到模块内部的 exports 接口对象 还有其它的一些规则，具体后面讲，以及如何在项目中去使用这种编程方式，会通过后面的案例来处理 核心模块 核心模块是由 Node 提供的一个个的具名的模块，它们都有自己特殊的名称标识，例如 fs 文件操作模块 http 网络服务构建模块 os 操作系统信息模块 path 路径处理模块 。。。。 所有核心模块在使用的时候都必须手动的先使用 require 方法来加载，然后才可以使用，例如： var fs = require('fs') http相关 端口号 ip 地址定位计算机 端口号定位具体的应用程序 Content-Type 服务器最好把每次响应的数据是什么内容类型都告诉客户端，而且要正确的告诉 不同的资源对应的 Content-Type 是不一样，具体参照：http://tool.oschina.net/commons 对于文本类型的数据，最好都加上编码，目的是为了防止中文解析乱码问题 通过网络发送文件 发送的并不是文件，本质上来讲发送是文件的内容 当浏览器收到服务器响应内容之后，就会根据你的 Content-Type 进行对应的解析处理 代码风格-无分号 JavaScript Standard Style Airbnb JavaScript Style 《编写可维护的 JavaScript》 //当你采用了无分号的代码风格的时候，只需要注意以下情况就不会有上面的问题了： // 当一行代码是以： // ( [ ` // 开头的时候，则在前面补上一个分号用以避免一些语法解析错误。 // 所以你会发现在一些第三方的代码中能看到一上来就以一个 ; 开头。 // ` 是 EcmaScript 6 中新增的一种字符串包裹方式，叫做：模板字符串 // EcmaScript 6 的 ` 字符串中，可以使用 ${} 来引用变量 nodemon 解决修改完代码自动重启 第三方命令行工具nodemon解决频繁修改代码重启服务器问题 nodemon是基于Node.js开发的第三方命令行工具 npm install --global nodemon #使用 会监视文件变化，当文件方生变化，自动帮你重启服务器 nodemon app.js 服务端渲染 即在服务端使用模板引擎 var http = require('http') var fs = require('fs') var template = require('art-template') var server = http.createServer() var wwwDir = 'D:/Movie/www' server.on('request', function (req, res) { var url = req.url fs.readFile('./template-apache.html', function (err, data) { if (err) { return res.end('404 Not Found.') } // 1. 如何得到 wwwDir 目录列表中的文件名和目录名 // fs.readdir // 2. 如何将得到的文件名和目录名替换到 template.html 中 // 2.1 在 template.html 中需要替换的位置预留一个特殊的标记（就像以前使用模板引擎的标记一样） // 2.2 根据 files 生成需要的 HTML 内容 // 只要你做了这两件事儿，那这个问题就解决了 fs.readdir(wwwDir, function (err, files) { if (err) { return res.end('Can not find www dir.') } // 这里只需要使用模板引擎解析替换 data 中的模板字符串就可以了 // 数据就是 files // 然后去你的 template.html 文件中编写你的模板语法就可以了 var htmlStr = template.render(data.toString(), { title: '哈哈', files: files }) // 3. 发送解析替换过后的响应数据 res.end(htmlStr) }) }) }) server.listen(3000, function () { console.log('running...') }) 服务端渲染和客户端渲染的区别 客户端渲染不利于 SEO 搜索引擎优化 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的 所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的 而是两者结合来做的 例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化 而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染 处理客户端响应 // app application 应用程序 // 把当前模块所有的依赖项都声明再文件模块最上面 // 为了让目录结构保持统一清晰，所以我们约定，把所有的 HTML 文件都放到 views（视图） 目录中 // 我们为了方便的统一处理这些静态资源，所以我们约定把所有的静态资源（images、css、js及模块）都存放在 public 目录中 var http = require('http') var fs = require('fs') var url = require('url') var template = require('art-template') // 创建服务器的简写方式 http .createServer(function (req, res) { //该函数会直接被注册为 server 的 request 请求事件处理函数 }) .listen(3000, function () { console.log('running...') }) 对用户路径请求处理 http .createServer(function (req, res) { // 使用 url.parse 方法将路径解析为一个方便操作的对象，第二个参数为 true 表示直接将查询字符串转为一个对象（通过 query 属性来访问） var parseObj = url.parse(req.url, true) // 单独获取不包含查询字符串的路径部分（该路径不包含 ? 之后的内容） var pathname = parseObj.pathname }) 控制用户访问 // 哪些资源能被用户访问，哪些资源不能被用户访问，我现在可以通过代码来进行非常灵活的控制 // /public 整个 public 目录中的资源都允许被访问 if (pathname.indexOf('/public/') === 0) { // 例 /public/css/main.css // 统一处理： // 如果请求路径是以 /public/ 开头的，则我认为你要获取 public 中的某个资源 // 所以我们就直接可以把请求路径当作文件路径来直接进行读取 fs.readFile('.' + pathname, function (err, data) { if (err) { return res.end('404 Not Found.') } res.end(data) }) 服务器让客户端重定向 // 如何通过服务器让客户端重定向？ // 1. 状态码设置为 302 临时重定向 // statusCode // 2. 在响应头中通过 Location 告诉客户端往哪儿重定向 // setHeader // 如果客户端发现收到服务器的响应的状态码是 302 就会自动去响应头中找 Location ，然后对该地址发起新的请求 // 所以你就能看到客户端自动跳转了 res.statusCode = 302 res.setHeader('Location', '/') res.end() 模块系统 使用Node编写应用程序主要是在使用： EcmaScript语言 核心模块 第三方模块 自定义模块 什么是模块化 文件作用域 通信规则 加载 require 导出 CommonJS模块规范 在 Node 中的 JavaScript 有一个概念：模块系统 模块作用域 使用 require 方法加载模块 使用 exports 接口对象用来导出模块中的成员 加载 require 语法 var 变量名 = require('模块') 两个作用： 执行被加载模块中的代码 得到被加载模块中的 exports导出接口对象 导出exports Node中是模块作用域，默认文件中所有成员只在当前文件模块有效 对于希望可以被其他模块访问的成员：就需要把这些公开成员都挂载到exports接口对象中 导出多个成员： exports.num = 123 导出单个成员(函数、字符串)： 如果一个模块需要直接导出某个成员，而非挂载，这时必须使用下面的方式 function add(){} module.exports = add module.exports = 'hello'//只会返回一个，后者会覆盖前者 原理 // 在 Node 中，每个模块内部都有一个自己的 module 对象 // 该 module 对象中，有一个成员叫：exports 也是一个对象 // 也就是说如果你需要对外导出成员，只需要把导出的成员挂载到 module.exports 中 var module = { exports: { foo: 'bar', add: function } } // 我们发现，每次导出接口成员的时候都通过 module.exports.xxx = xxx 的方式很麻烦，点儿的太多了 // 所以，Node 为了简化你的操作，专门提供了一个变量：exports 等于 module.exports var exports = module.exports // 两者一致，那就说明，我可以使用任意一方来导出内部成员 // 当一个模块需要导出单个成员的时候 // 直接给 exports 赋值是不管用的 exports = {} //给 exports 赋值会断开和 module.exports 之间的引用 复杂数据是引用 //但最后 return 的是 module.exports //所以exports再怎么赋值也不会影响到return的结果 // 同理，给 module.exports 重新赋值也会断开 // 这里导致 exports !== module.exports module.exports = { foo: 'bar' } //之后exports再怎么赋值也不会影响到return的结果 // 谁来 require 我，谁就得到 module.exports // 默认在代码的最后有一句： // 一定要记住，最后 return 的是 module.exports // 不是 exports！ // 所以你给 exports 重新赋值不管用， return module.exports require 方法加载规则 优先从缓存加载 如果要加载的b模块已经在加载a模块时加载了，那么就不会重复加载 判断模块标识 核心模块 核心模块的本质也是文件 核心模块文件已经被编译到了二进制文件中了，我们只需要按照名字来加载就可以了 第三方模块 凡是第三方模块都必须通过 npm 来下载 使用的时候就可以通过 require('包名') 的方式来进行加载才可以使用 不可能有任何一个第三方包和核心模块的名字是一样的 查找规则 先找到当前文件所处目录中的 node_modules 目录 node_modules/art-template --> node_modules/art-template/package.json 文件 --> node_modules/art-template/package.json 文件中的 main 属性 --> main 属性中就记录了 art-template 的入口模块 如果 package.json 文件不存在或者 main 指定的入口模块也没有,则 node 会自动找该目录下的 index.js 如果以上所有任何一个条件都不成立，则会进入上一级目录中的 node_modules 目录查找，直到磁盘根目录 自定义模块 npm node package manager //一个项目有且只有一个 node_modules，放在项目根目录中 npm install --save//安装第三方包时最好加上--save 会在package.json 中生成dependencies 保存第三方包依赖信息 常用命令 npm install 安装包 install 可简写成 i 可添加--save保存依赖信息可简写成-S npm uninstall 删除包 可添加--save把依赖信息一起去除 解决npm被墙问题 http://npm.taobao.org/ npm淘宝镜像 安装淘宝的cnpm #在任意目录执行都可以 --global表示安装到全局 npm install --global cnpm #以后安装包时把npm替换成cnpm就行 安装时添加地址使用淘宝服务器下载 #临时使用 npm install --registry https://registry.npm.taobao.org install express #持久使用 npm config set registry https://registry.npm.taobao.org #查看配置信息 npm config list packgae.json 建议每一个项目都要有一个 package.json 文件（包描述文件，就像产品的说明书） 这个文件可以通过 npm init 的方式来初始化出来 当项目的node_modules文件夹丢失，可以通过 npm install 会根据package.json自动下载依赖 建议执行 npm install --save 用来保存依赖项信息 npm 5.0 之后使用 npm install 会自动加入 dependencies 的依赖项，不需加 --save，还会自动创建 package-lock.json package-lock.json 这个文件的作用：记录依赖信息；锁定版本号，防止自动升级 Node 中的非模块成员 在每个模块中，除了 require 、 exports 等模块相关 API 之外，还有两个特殊的成员： __dirname 获取 当前文件 模块所属目录的绝对路径 __filename 获取 当前文件 的绝对路径 在文件操作中，使用相对路径是不可靠的，因为在 Node 中文件操作的路径被设计为相对于执行 node 命令所处的路径，可以将相对路径替换为绝对路径 path.join(__dirname,'...') 推荐：所有跟文件操作相关的都使用 动态的绝对路径 模块中路径标识不受执行 node 命令所处路径影响（引用自定义模块使用绝对路径不受影响） Express Node.js的Web开发框架 -- 封装的http init 安装 npm install --save express hello world const express = require('express') const app = express() app.get('/',(req,res) => res.send('Hello World!')) app.listen(3000,() => console.log('Example app listening on port 3000')) 基本路由 路由器 请求方法 请求路径 请求处理函数 get： app.get('/', function (req, res) { res.send('Hello World!') }) post： app.post('/', function (req, res) { res.send('Got a POST request') }) 静态服务 // 开放指定目录 ./public/ 下的资源 // 当省略第一个参数时 可以通过省略 /public 的方式来访问 .../js/a.js app.use(express.static('./public/')) // 当以 /public/ 开头时，去./public/目录中查找对应资源 .../public/js/a.js app.use('/public/', express.static('./public/')) // 当以 /a/ 开头时，去./public/目录中查找对应资源 .../a/js/a.js app.use('/a/', express.static('./public/')) // 当以 /public/ 开头时，以绝对路径查找 /public app.use('/public', express.static(path.join(__dirname, './public'))) 在Express配置art-template模板引擎 参考文档：art-template docs 安装： npm install --save art-template npm install --save express-art-template 配置： // 第一个参数，表示，当渲染以 .html 结尾的文件的时候，使用 art-template 模板引擎 app.engine('html', require('express-art-template')) 使用： // Express 为 Response 相应对象提供了一个方法：render // render 方法默认是不可以使用，但是如果配置了模板引擎就可以使用了 app.get('/', function (req, res) { //express 默认会去项目中的 views 目录查找index.html //Express 有一个约定：开发人员把所有的视图文件(html文件)都放到 views 目录中 res.render('index.html', { comments: comments }) }) 如果希望修改默认的views 视图渲染存储目录可以： // 第一个参数是默认的 表示修改views为xxx app.set('views', 目录路径) 在 Express 获取表单 GET 请求体数据 Express 内置了一个API，可以直接通过 req.query 来获取 req.query 在 Express 获取表单 POST 请求体数据 在Express中没有内置获取表单POST请求体的API，需要使用第三方包：body-parser 安装： npm install --save body-parser 配置： var express = require('express') //0.引包 var bodyParser = require('body-parser') var app = express() // 配置 body-parser 中间件 // 只要加入这个配置，则在 req 请求对象上会多出来一个属性：body // parse application/x-www-form-urlencoded app.use(bodyParser.urlencoded({ extended: false })) // parse application/json app.use(bodyParser.json()) 使用： app.use(function (req, res) { // 可以通过 req.body 来获取 POST 请求体数据 res.end(JSON.stringify(req.body, null, 2)) }) 在 Express 中包装路由 router.js: // 专门用来包装路由的 var express = require('express') // 1. 创建一个路由容器 var router = express.Router() // 2. 把路由都挂载到 router 路由容器中 替代app.get() router.get('/students/new', function (req, res) { res.render('new.html') }) // 3. 把 router 导出 module.exports = router app.js: // 4. 把路由容器挂载到 app 服务中 ---在入口文件中 var router = require('./router') app.use(router) Session 在 Express 中默认不支持 Session 和 Cookie 但是我们可以使用第三方中间件：express-session 来解决 下载： npm i express-session 配置： var express = require('express') var session = require('express-session') var app = express() // 一定要在app.use(router)之前 // 该插件会为 req 请求对象添加一个成员：req.session 默认是一个对象 app.use(session({ // 配置加密字符串，它会在原有加密基础之上和这个字符串拼接起来去加密 // 目的：为了增加安全性，防止客户端恶意伪造 secret: 'keyboard cat', resave: false, saveUninitialized: true // 无论是否使用 Session ，默认直接分配一把钥匙给客户端 })) 使用： // 添加 Session 数据 req.session.foo = 'bar' // 获取 Session 数据 req.session.foo // 删除 req.session.foo = null delete req.session.foo tips：默认 Session 数据是内存存储的，服务器一旦重启就会丢失 ，真正的生产环境会把 Session 进行持久化存储 Express 中间件 参考文档：express middleware 应用程序级别中间件 使用和函数将应用程序级中间件绑定到app对象的实例 // 没有装载路径的中间件功能。每次应用程序收到请求时都会执行该功能。 var app = express() // 不关心请求路径和请求方法的中间件,任何请求都会进入这个中间件 app.use(function (req, res, next) { console.log('Time:', Date.now()) next() // 如果请求进入中间件之后，没有调用 next 则代码会停在当前中间件 // next 是一个方法，用来调用下一个中间件的 // 调用 next 方法也是要匹配的（不是调用紧挨着的那个） }) // /user/:id路径上安装的中间件功能。对/user/:id路径上的任何类型的HTTP请求执行该功能。 app.use('/user/:id', function (req, res, next) { console.log('Request Type:', req.method) next() }) // 严格匹配请求方法和请求路径的中间件 app.get app.post // 路由及其处理函数（中间件系统）。该函数处理对/user/:id路径的GET请求 app.get('/user/:id', function (req, res, next) { res.send('USER') }) // 如果没有能匹配的中间件，则 Express 会默认输出：Cannot GET 路径 路由级别中间件 路由器级中间件的工作方式与应用程序级中间件的工作方式相同，只不过它被绑定到一个实例express.Router()。 var router = express.Router() // 与应用级别的相同，只不过把 app 换成 router router.use(function (req, res, next) { console.log('Time:', Date.now()) next() }) // 其他省略 错误处理中间件 错误处理中间件总是需要四个参数。您必须提供四个参数以将其标识为错误处理中间件函数。 app.get('/', function (req, res, next) { fs.readFile('.d/sa./d.sa/.dsa', function (err, data) { if (err) { // 当调用 next 的时候，如果传递了参数，则直接往后找到 错误处理中间件 // 当发生错误的时候，我们可以调用 next 传递错误对象 // 然后就会被全局错误处理中间件匹配到并处理之 next(err) } }) }) // 错误处理中间件 // (err, req, res, next) 顺序不能乱，个数不能少 app.use(function (err, req, res, next) { console.error(err.stack) res.status(500).send('Something broke!') }) 内置中间件 Express 内置中间件的功能： /* 例如 express.static 提供静态资产，如HTML文件，图像等 express.json 使用JSON有效负载解析传入的请求 express.urlencoded 使用URL编码的有效负载解析传入的请求 */ 第三方中间件 使用第三方中间件为Express应用程序添加功能。 安装Node.js模块以获得所需的功能，然后在应用程序级别或路由器级别将其加载到您的应用程序中。 以下示例说明了安装和加载cookie解析中间件功能cookie-parser。 npm install cookie-parser var express = require('express') var app = express() var cookieParser = require('cookie-parser') // load the cookie-parsing middleware app.use(cookieParser()) MongoDB 菜鸟教程 关系型数据库和非关系型数据库 所有关系型数据库都需要 sql 语言来操作 所有的关系型数据库在操作之前都需要设计表结构 而且数据表还支持约束 唯一的 主键 默认值 非空 非关系型数据库非常的灵活 MongoDB是最像关系型数据库的非关系型数据库 数据库-》数据库 数据表-》集合（数组） 表记录-》（文档对象) MongoDB不需要设计表结构 启动和关闭 启动： # mongodb 默认使用 mongod 命令 以所处盘符根目录下的 /data/db 作为自己的数据存储目录 # 所以在第一次执行时应手动创建一个 /data/db mongodb 如果想要修改默认数据存储目录 mongod --dbpath=数据存储目录 关闭： ctrl + c 连接和退出 连接： # 默认连接本机的 MongoDB 服务 mongo 退出： exit 基本命令： # 查看所有数据库 show dbs # 切换到指定数据库（没有则新建） use 数据库名 # 查看当前操作的数据库 db # 插入数据 Node 操作 MongoDB 数据库 使用官方的 mongodb 包操作 https://github.com/mongodb/node-mongodb-native 使用第三方 mongoose 来操作 MongoDB 数据库 第三方包：mongoose 基于 MongoDB 官方的 mongodb 包再一次做了封装 mongoose 官网：https://mongoosejs.com/ 官方指南：https://mongoosejs.com/docs/guide.html 官方 API 文档：https://mongoosejs.com/docs/api.html init 安装： npm i mongose hello world: var mongoose = require('mongoose'); // 连接 MongoDB 数据库 mongoose.connect('mongodb://localhost/test', { useMongoClient: true }); mongoose.Promise = global.Promise; // 创建一个模型 就是在设计数据库 // MongoDB 是动态的，非常灵活，只需要在代码中设计你的数据库就可以了 // mongoose 这个包就可以让你的设计编写过程变的非常的简单 var Cat = mongoose.model('Cat', { name: String }); // 实例化一个 Cat var kitty = new Cat({ name: '喵喵' + i }); // 持久化保存 kitty 实例 kitty.save(function (err) { if (err) { console.log(err); } else { console.log('meow'); } }); 官方指南 设计 Schema 发布 Model ： var mongoose = require('mongoose') // 架构 var Schema = mongoose.Schema // 1. 连接数据库 // 指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来 mongoose.connect('mongodb://localhost/itcast') // 2. 设计文档结构（表结构） // 字段名称就是表结构中的属性名称 var userSchema = new Schema({ username: { type: String, required: true // 必须有 }, password: { type: String, required: true }, email: { type: String } }) // 3. 将文档结构发布为模型 // mongoose.model 方法就是用来将一个架构发布为 model // 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称 // mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称 // 例如这里的 User 最终会变为 users 集合名称 // 第二个参数：架构 Schema // 返回值：模型构造函数 var User = mongoose.model('User', userSchema) // 4. 当我们有了模型构造函数之后，就可以使用这个构造函数对 users 集合中的数据（增删改查） 增加 var admin = new User({ username: 'zs', password: '123456', email: 'admin@admin.com' }) admin.save(function (err, ret) { if (err) { console.log('保存失败') } else { console.log('保存成功') } }) 查询 查询所有： User.find(function (err, ret) { if (err) { console.log('查询失败') } else { console.log(ret) } }) 按条件查询所有：返回多个对象组成的 数组 User.find({ username: 'zs' }, function (err, ret) { if (err) { console.log('查询失败') } else { console.log(ret) } }) 查询单个：返回一个 对象 User.findOne({ username: 'zs' }, function (err, ret) { if (err) { console.log('查询失败') } else { console.log(ret) } }) 删除 User.remove({ username: 'zs' }, function (err, ret) { if (err) { console.log('删除失败') } else { console.log('删除成功') } }) 更新 User.findByIdAndUpdate('5a001b23d219eb00c8581184', { password: '123' }, function (err, ret) { if (err) { console.log('更新失败') } else { console.log('更新成功') } }) Node 操作 MySQL 数据库 安装： npm install mysql --saves 配置： var mysql = require('mysql'); // 1. 创建连接 var connection = mysql.createConnection({ host: 'localhost', user: 'root', password: 'root', database: 'db' }); // 2. 连接数据库 connection.connect(); // 3. 执行数据操作 所有的数据库操作都在参数1写 connection.query('SELECT * FROM `users`', function (error, results, fields) { if (error) throw error; console.log('The solution is: ', results); }); // 4. 关闭连接 connection.end(); 异步编程 回调函数 异步编程 如果需要得到一个函数内部异步操作的结果，这是时候必须通过回调函数来获取 在调用的位置传递一个函数进来 在封装的函数内部调用传递进来的函数 服务端重定向只针对同步请求，异步请求无效 "},"nodejs/API.html":{"url":"nodejs/API.html","title":"nodejs API","keywords":"","body":"require /* require 是一个方法 它的作用就是用来加载模块的 在 Node 中，模块有三种： 具名的核心模块，例如 fs、http 用户自己编写的文件模块 相对路径必须加 ./ 可以省略后缀名 相对路径中的 ./ 不能省略，否则报错 在 Node 中，没有全局作用域，只有模块作用域 外部访问不到内部 内部也访问不到外部 默认都是封闭的 既然是模块作用域，那如何让模块与模块之间进行通信 有时候，我们加载文件模块的目的不是为了简简单单的执行里面的代码，更重要是为了使用里面的某个成员*/ /* require 方法有两个作用： 1. 加载文件模块并执行里面的代码 2. 拿到被加载文件模块导出的接口对象 在每个文件模块中都提供了一个对象：exports exports 默认是一个空对象 你要做的就是把所有需要被外部访问的成员挂载到这个 exports 对象中*/ fs fs 是 file-system 的简写，就是文件系统的意思，在 Node 中如果想要进行文件操作，就必须引入 fs 这个核心模块，在 fs 这个核心模块中，就提供了所有的文件操作相关的 API fs.readFile() /*读取文件 第一个参数就是要读取的文件路径 第二个参数是一个回调函数 成功 data 数据 error null 失败 data undefined没有数据 error 错误对象*/ fs.readFile('./data/a.txt', function (error, data) { // // 文件中存储的其实都是二进制数据 0 1 // 这里为什么看到的不是 0 和 1 呢？原因是二进制转为 16 进制了 // 所以我们可以通过 toString 方法把其转为我们能认识的字符 // 在这里就可以通过判断 error 来确认是否有错误发生 if (error) { console.log('读取文件失败了') } else { console.log(data.toString())//用以下方法代替 } }) fs.readFile('./data/a.txt', 'utf8' function (error, data) {// 如果是string，自动转换为 utf8 而不是二进制 } fs.readdir() var fs = require('fs') //以数组的方式返回该目录下的所有文件/文件夹 fs.readdir('D:/Movie/www', function (err, files) { if (err) { return console.log('目录不存在') } console.log(files) }) http var http = require('http') var server = http.createServer() // request 请求事件处理函数，需要接收两个参数： // Request 请求对象 // 请求对象可以用来获取客户端的一些请求信息，例如请求路径 // Response 响应对象 // 响应对象可以用来给客户端发送响应消息 server.on('request', function (request, response) { console.log('收到客户端的请求了，请求路径是：' + request.url) // response 对象有一个方法：write 可以用来给客户端发送响应数据 // write 可以使用多次，但是最后一定要使用 end 来结束响应，否则客户端会一直等待 response.write('hello') // 告诉客户端，我的话说完了，你可以呈递给用户了 // response.write()的方式比较麻烦，推荐使用更简单的方式，直接 end 的同时发送响应数据 // response.end()可以接收 二进制 字符串 // 一次请求对应一次响应 response.end()后面的代码不执行 response.end() // 在服务端默认发送的数据，其实是 utf8 编码的内容 // 但是浏览器不知道你是 utf8 编码的内容 // 浏览器在不知道服务器响应内容的编码的情况下会按照当前操作系统的默认编码去解析 // 中文操作系统默认是 gbk // 解决方法就是正确的告诉浏览器我给你发送的内容是什么编码的 // 在 http 协议中，Content-Type 就是用来告知对方我给你发送的数据内容是什么类型 // res.setHeader('Content-Type', 'text/plain; charset=utf-8') response.end('hello 世界') }) server.listen(3000, function () { console.log('服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来进行访问') }) url 将 类似 /pinglun?name=jack&message=hello 这种请求转换为 Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '?name=jack&message=hello', query: 'name=jack&message=hello', pathname: '/pinglun', path: '/pinglun?name=jack&message=hello', href: '/pinglun?name=jack&message=hello' } var url = require('url') var obj = url.parse('/pinglun?name=jack&message=hello', true) // 第二个参数默认为false // 设为true时 query：{ { name: 'jack', message: 'hello' }} // /pinglun?name=jack&message=hello // 对于这种表单提交的请求路径，由于其中具有用户动态填写的内容 // 所以你不可能通过去判断完整的 url 路径来处理这个请求 // 结论：对于我们来讲，其实只需要判定，如果你的请求路径是 /pinglun 的时候，那我就认为你提交表单的请求过来了 path path.basename() // 获取文件名 path.basename('c:/a/b/c/index.js')// index.js path.basename('c:/a/b/c/index.js','.js')// index path.dirname() // 获取路径部分 path.dirname('c:/a/b/c/index.js')// c:/a/b/c path.extname() // 获取扩展名 path.extname('c:/a/b/c/index.js')// .js path.parse() // 将路径解析成一个对象 path.parse('c:/a/b/c/index.js') /* { root: 'c:/', dir: 'c:/a/b/c', base: 'index.js', ext: '.js', name: 'index' }*/ path.isAbsolute() // 判断是否是绝对路径 path.isAbsolute('c:/a/b/c/index.js')// true path.join() // 路径拼接 path.join('c:/a', 'b')// c:/a/b "},"PHP/":{"url":"PHP/","title":"PHP","keywords":"","body":"PHP PHP 基础 PHP 样例 建站流程 "},"PHP/base.html":{"url":"PHP/base.html","title":"PHP 基础","keywords":"","body":"Apache httpd.conf详解 httpd.conf是apache的主配置文件 1、ServerRoot apache安装位置 ServerRoot \"D:/wamp/apache2.4\" 2、Listen apache监听端口号 3、ServerAdmin 管理员邮箱 4、ServerName 域名 5、DocumentRoot 用于设置站点的根目录 6、Diretory配置段 主要用于对站点根目录的特性的设置 ServerName www.one.com DocumentRoot \"D:/wamp/apache2.4/htdocs\" DirectoryIndex #用于设置默认首页 Options Indexes FollowSymLinks MultiViews #是否列出目录结构，当请求文件不存在时，列出目录结构,加#号注释为否 AllowOverride All或None #是否开启外部配置文件 关闭：不写或者后面写none Order #用于配置此目录的访问权限 语法一：Order deny,allow #如果没有明确的拒绝则允许 deny from ip地址 allow from all 语法二：Order allow,deny #如果没有明确的允许则全部拒绝 allow from ip地址 deny from all Require All Granted #所有的请求都需授权 httpd.exe作用 使用终端打开 httpd.exe -k start/stop/restart apache服务的启动/停止/重启 httpd.exe -t 配置文件的语法检查 虚拟主机配置 使用一个apache软件，配置多个主机（域名） 1、在主配置文件中开启扩展配置文件(Include conf/extra/httpd-vhosts.conf)，去掉# 2、配置conf/extra/httpd-vhosts.conf文件，跟在主配置文件的写法的一样 放在 里 3、把主配置文件原来的配置注释掉 外部配置文件 除主配置文件conf/httpd.conf和扩展配置conf/extra外的配置文件 创建.htaccess放在站点根目录下，优先级比前两个高，并且不用重启apache 配置跟前两个一样 自定义错误提示页面 语法: ErrorDocument 错误代码(404) /错误提示文件 MySQL 安装过程 cd C:\\Develop\\mysql\\bin mysqld --initialize --user=mysql --console 初始化 mysqld --install MySQL 安装名字为MySQL的服务 net start MySQL 启动服务 mysql -u root -p set password for root@localhost = password('123456'); 更改密码 PHP apache加载PHP功能模块 在apache主配置文件中，加载php模块 LoadModule php5_module \"D:/wamp/php5.6/php5apache2_4.dll\" 在apache主配置文件中，设置php文件扩展名 AddType Application/x-httpd-php .php 在apache主配置文件中，设置php配置文件 php.ini配置文件的设置不影响php运行，但是会影响php的一些扩展功能，php.ini 由php.ini-development或php.ini-production更名获得 PHPIniDIR \"D:\\wamp\\php5.6\\php.ini\" 语法规则 主配置文件中设置了php文件的扩展名.php，所以所有的php文件的扩展名都是.php php文件必须通过域名访问，文件中（包括路径）不能包括中文 php每一条语句后必须有';' php中变量名区分大小写，其余函数名、方法名、类名都不区分大小写 PHP标记 1、标准的 2、script格式 3、短格式(默认没有开启) 在php.ini中short_open_tag = on/off（开启短格式的标签） 4、asp格式 在php.ini中asp_tag = on/off（开启asp格式的标签） 注释 单行注释： //注释内容 多行注释： /*多行注释*/ 变量 声明语法 $变量名=值; 要使用也需带有$ 删除变量 unset($变量名)； 可变变量 20 ?> 预订变量 $_GET 用于接受前台表单使用get方式提交的数据 $_POST 用于接受前台表单使用get方式提交的数据 $_REQUEST 用于接受前台表单使用get或post方式提交的数据 $_SERVER 记录服务器端与客户端的相关信息 $_COOKIE 一种会话技术 $_SESSION 一种会话技术 $_FILES 用于记录用户上传的文件信息 $GLOBAL 用于记录全局变量 内存结构 1、栈区 保存的是变量名（术语称之为引用） 特点：对于cpu来说，读写速度是最快的 2、数据段 数据全局区：存储的是简单的数据，例如：整形、浮点型、布尔值 数据静态区：存储静态变量和常量 3、堆区 存储的是\"复杂\"的数据，字符串、数组、对象 4、代码段 存储的是源代码对应的机器指令 5、输出缓存 只要是遇到输出命令，例如：echo、print、这些指令都会将所要输出数据放在输出缓存中 数据存储方式： $v1=10; $v2=$v1;//找到v1存储的内容10，复制一份给v2，在数据区申请空间存v2的值 php嵌入到html中 php仅处理标签内的代码，js、html、css对php来说都是字符串 php中变量的传值方式 1、赋值传值 使用一个变量a为另一个变量b赋值时，传递的是变量a的值 2、引用传值 使用一个变量a为另一个变量b赋值时，传递的是变量a的地址 //v1与v2指向同一个地址 提示 js中不允许人为的更改传值方式，但是PHP中可以使用地址符'&'，来将赋值传值更改为引用传值（单向的），常量默认区分大小写，一般建议在命名时使用全大写形式 常量 常量一旦定义就不允许更改其值，也不允许删除，常量的值只能是基本数据类型(标量数据类型) 语法 1、define('常量名',值); 2、const 常量名=值; 区别 define语法可以在分支结构（if语句）中定义常量，const不行 define定义的常量可以自定义是否区分大小写;define('常量名',值,true);//不区分 判断常量是否存在及获取常量 defined('常量名');//返回true或false get_defined_constants();//获取所有常量，返回数组格式 魔术常量 __FILE__ 获取当前文件完整路径及文件名 __DIR__ 获取当前文件路径 __LINE__ 此代码所处的行号 __FUNCTION__ 获取当前函数的函数名 __METHOD__ 获取当前方法的方法名 __CLASS__ 获取当前类的类名 __NAMESPACE__ 获取当前空间的空间名 数据类型 1、标量(scalar)数据类型 int整型、float浮点、boolean布尔、string字符串 2、复合数据类型 array数组、object对象 3、特殊数据类型 null、resource资源类型、 整型 线性的整数 十进制、八进制（以0开头）、十六进制（以0x开头） 在显示时会自动转化为十进制 浮点类型 带有小数点的数 $v1=3.5;//法1 $v2=1.25E-3;//法2 //注意小数间计算 得到的结果精度不精确 字符串类型 使用单引号或双引号括起来的0个或多个字符 1、使用单引号定义的字符串 能够被转义的字符有'\\\\' \\' 单引号定义的字符串中的变量不能被解析 2、使用双引号定义的字符串 能够被转义的字符有 \\\" \\t \\r \\n \\\\ \\$ 双引号定义的字符串中的变量会被解析（变量名应用\"{}\"括起来，范围解析限定符） 3、heredoc 也是使用双引号定义字符串的，定义大段的字符串 //heredoc是变量名，可随意定义 $heredoc = 布尔类型 只有true和false 数组类型 1、索引数组 数组元素的下标是数值 2、关联数值 数组元素的下标是字符串 echo $_SERVER['REMOTE_ADDR'];//不加引号会解析成常量 $V1=\"$_SERVER[REMOTE_ADDR]\";//在字符串内不需再加引号，不会当成常量看待 $v2=\"{$_SERVER['REMOTE_ADDR']}\"; //相当于字符串的拼接; //\".$_SERVER['REMOTE_ADDR'].\";php用点拼接字符串 null类型 只有一个值，null 资源类型 resoure类型：也是一个特殊的变量，没有办法直接定义一个资源，必须使用php提供的获取资源的函数 数据类型的转换 1、自动转换 $v1=100; $v2='100元'; echo $v1*$v2;//10000 //*号是算术运算符，会将字符串自动转换为数字类型 2、强制转换 (integer)变量 将其他数据类型转换为整型 (float)变量 将其他数据类型转换为浮点型 (array)变量 将其他数据类型转换为数组 (object)变量 将其他数据类型转换为对象 (string)变量 将其他数据类型转换为字符串 (boolean)变量 将其他数据类型转换为布尔值 '0'-->false 0.0-->false 未定义的变量-->false 数据类型的判断 is_int(v); is_string(v); is_bool(v); is_scalar(v);标量 is_resource(v);.... isset(v) 判断变量是否设置值（判断是否为null）只有null或该变量不存在才false empty(v) 判断变量v的值是否为\"空\"===>等效于false的值，如果是空则返回true empty($dict['foo'])===!isset($dict['foo'])||$dict['foo']==false 运算符 字符串运算符 . 对字符串进行拼接 .= 对字符串进行拼接 如果拼接一个数值，数值与.之间要有空格，否则会解析成小数 $str='$i的值为：'. 10没有空格会被当作0.10 比较运算符 == 用于判断两个数的值是否相等 '10'==10 ---->true === 同时判断变量的值与类型是否相等 '10'===10 --->false，类型不同 逻辑运算符 逻辑与短路 && 如果第一个操作数是false，后面的就不会操作 $n =10; false && ++$n; echo $n;//10;++不执行 逻辑或短路 || 如果第一个为true，后面的就不会操作 强制转换布尔 $v1=10; !!$v1;//true and 逻辑与 运算规则与&&相同，唯一的区别是&&的优先级高于=；而and的优先级低于= or 逻辑或 运算规则与||相同，唯一的区别是||的优先级高于=；而or的优先级低于= 条件运算符 三元运算符 表达式？表达式A：表达式B； 运算符的优先级 单、算、关、逻、条、赋、逗 错误控制运算符 1、 @ 错误抑制符 作用是不显示错误信息 $link=@mysqli_connect('127.0.0.1','root','123'); //在语句之前加了@之后即使有错误，也不会出现提示 2、 php.ini中设置隐藏错误 全局不显示 display_errors=on/off 3、 脚本级的错误控制仅限于当前的php脚本文件 ini_set() 主要用于在php脚本中来设置php.ini中的配置项 ini_set(配置项名,值) 位运算符 & 按位与 两个操作数的二进制形式对应的位进行与运算 | 按位或 ^ 按位异或 相同为0,不同为1 可以用来互换两个数的数据 ~ 按位非 >> 右移 右侧溢出忽略，左侧补0，移一位/2 进制转换函数 decbin(v)； 十进制转二进制 dechex(v); 十进制转十六进制 decoct(v); 十进制转八进制 php输出语句 echo 只能输出标量数据类型，将任何东西转换为字符串输出，true转为1,false转为空；数组不能转换--->报错 print(); 同echo，区别：print只能输出一个，echo能输出多个用','分隔，print不是函数可以省略\"()\" print_r(); 可以输出标量及复合数据类型，但布尔值会被转换为1或空 var_dump(); 主要是程序员进行代码调试，可以输出十分详细的信息（类型及值、字符串|数组长度） sprintf(); 用于格式化输出 /* sprintf(格式化字符串,数值1,数值2,...); %b 二进制 %d 十进制 %o 八进制 %f 浮点 %x 十六进制 */ echo sprintf('255的八进制为：%o',255); 字符集 ASCII 一个字符占据1个字节，127个英文 GBK 一个字符占据2个字节，中文 UTF-8 一个字符占据3个字节，世界词典 流程控制 分支结构 if语句 如果语句体只有一条语句，此语句的{}可以省略 if(表达式A){ 语句体A }elseif(表达式B){ 语句体B } switch语句 switch(变量){ case 值1: 语句体1; break;//break可以省略，但会继续执行下面的语句，直到结束或遇到break default: 缺省语句体; } 循环结构 for循环 for(循环的控制变量初始化;表达式;循环控制变量的更改){ //循环体 } while循环 //循环的控制变量初始化 while(表达式){//直到表达式成立 //循环体 //循环控制变量的更改 } do while循环 do{ //循环体 }while(表达式)//直到表达式不成立 循环的结束与退出 continue continue [n]; /*n为整数，默认为1 n主要是用在循环嵌套的情况下 结束当前循环结构的本次循环，继续上n层循环结构的下一次循环 */ break break [n]; /*n为整数，默认为1 n主要是用在循环嵌套的情况下 直接结束上n层循环结构循环 */ 流程控制语句的标签语法 标准语法： //{换成: //}换成endfor 简化语法： //if while 都可以 文件载入 引入其他的html或php文件 require require(文件名); require_once(文件名); include include(文件名); include_once(文件名); 在同一文件内，函数可以先调用后声明，变量不行；在编译的过程就已经存在于代码段 引入的文件如果有函数，记得先引入再调用 目的： 1、在php文件中获取数据，在html文件中显示数据，php引入html文件 2、在当前文件（php）中想使用另一文件（php）中的功能性代码 引入路径的问题 在项目中，对于html文件，是不允许用户直接请求的，而是指向一个php文件，让php文件来引用这个html文件。 当一个php文件引入一个html文档时，html文件本身也会引入一些其他的文件，如：图片文件、css文件、js文件。这时会引发路径更改问题。路径要以当前php文件所在的路径为起点。被引用的html中应，如下写法： include与require的区别 include在引入文件时，被引入文件不存在则会报错，但程序还会继续向下执行 require在引入文件时，被引入文件不存在则中断程序 经验： require一般用于引入php文件，因为php里面一般是功能性代码 include一般用于引入html文件 include_once、require_once每次在引入文件时，都会检查之前有没被引入过，有引入就不会再引入,只执行一次；而require和include则没有 ## 错误处理 ### 错误的触发 #### 系统错误的触发 程序员无法干涉系统错误，系统编译不通过自动触发 #### 自定义的错误 trigger_error(); ```php trigger_error(msg,type); //msg:错误描述信息 //type:自定义错误的代码(E_USER_ERROR、E_USER_WARNING、E_USER_NOTICE) if(!is_array($listArr)){ trigger_error('参数类型不正确',E_USER_NOTICE); } //Notice：参数类型不正确 in ... //使用错误处理机制的好处：可以将错误记录起来，默认会被记录到apache的/logs/error.log文件 函数 可变函数 将函数名赋值给变量 function nxn($name){//形参有$ echo \"hello world $name\"; } $f=nxn;//根据赋值的不同，下面调用时的函数也不同 $f(); 匿名函数 function (){ echo __FUNCTION__;//{closure}闭包 };//匿名函数必须以分号结尾 php匿名函数无法自调用！ 主要用于赋值给一个变量，还可以用于某个函数的参数（作为回调函数） 函数的参数 形参的默认值 function showInfo($i=100){ echo $i; } 形参的引用传值 function showInfo(&$v1,&$v2){//不加&，是正常的赋值传值 $v1=100; $v2=200; echo $v1,$v2;//100,200 } $a=10; $b=20; showInfo($a,$b); echo $a,$b;//100,200 //引用传值，即将$a,$b的地址传递给形参，形参在函数内部更改也会影响外部的值 相关参数（系统函数） func_get_args(); 用于获取实参，并以数组的形式返回 func_get_arg(index); 用于获取index下标指定的实参 func_num_args(); 用于获取实参的个数 function getNum(){ echo '实参的个数为：',func_num_args(); echo '第一个实参为：',func_get_arg(0); echo '所有参数为：',print_r(func_get_args()); } getNum(10,20,30); //另一种函数未知实参的个数 function getNum(...$args){//用于将实参以数组的形式保存在这个变量中 print_r($args); } 作用域 全局作用域与全局变量 在函数外部定义的变量，其作用域就是全局作用域，变量就是全局变量 php中，函数内部不能访问全局变量！ 局部作用域与局部作用域 函数内部定义的变量，其作用域就是局部作用域，这个变量就是局部变量 php中，函数外也不能访问局部变量 php中的作用域，外部只能访问外部的，内部只能访问内部的 global关键字 1、通过传址的方式 通过形参加&引用传值的方式使内外部互通 $i=10; function showInfo(&$p){ $p+=10; echo $p; } showInfo($i);//20 echo $i;//20 2、$GLOBALS 全局变量会自动保存在$GLOBALS中 $_GET、$_POST、$GL OBALS ...超全局变量 $name='tom'; function showInfo(){ echo $GLOBALS['name'];//通过GLOBALS可以实现内部访问外部的全局变量 } showInfo(); 3、global关键字 //global $变量名; $i=10; function showInfo(){ global $i;//用于函数内，不能用于赋值，只能声明；用于获取外部全局变量或将内部局部变量变为全局变量 echo $i; } showInfo(); /* 在函数内部创建一个与函数外部同名的变量的引用；如果外部没有这样的同名变量，会在外部创建一个同名的变量 global只能获取全局变量，一个函数内的无法global另一个函数内的变量 */ 静态变量 在函数内部使用static的变量 静态变量在函数多次被调用时，只会被初始化一次，并且静态变量的值并不会随着函数执行后被销毁 在函数的下一次调用时，仍然可以访问其值 function showInfo(){ static $i=1;//变量i的值存储在数据段静态区，函数执行结束后，i不会被销毁；由于static存在，只会初始化一次 $i++; echo $i; } showInfo();//2 showInfo();//3 showInfo();//4 系统函数 日期时间函数 time(); 用于获取当前时间的时间戳，单位秒；时间戳就是从时间原点到现在的一个秒数 默认格林威治时间 设置时区 1 date_default_timezone_set('PRC'); 2 配置文件php.ini date.timezone=PRC mocrotime(); 毫秒（秒为单位）+秒；不重要 data(); 用于格式化时间 data(format[,time]); echo data('Y-m-d H:i:s');//遇到以下字符自动转换，可以Y年m月之类的格式 //Y--4位年份;m--月份，两位;d--日期;H--24小时制;i--分钟;s--秒 mktime(); 获取指定时间的时间戳 mktime(时，分，秒，月，日，年); strtotiem(); 将有格式的时间字符串转换为时间戳 字符串 字符串的长度 1、strlen(变量);//计算的是字节数，对于汉字等多字节字符不友好 2、多字节字符的支持 在php.ini中打开 extension=php_mbstring.dll，打开之后就可以 $str='hello你好'; //php中对于宽字符集的处理都是在前面加mb_的函数 //但是需要加载php_mbstring.dll //在php的安装目录创建一个php.ini //将extension_dir=\"绝对路径\" //extension=php_mbstring.dll解开注释 //修改apache配置文件加载php.ini默认位置 //PHPIniDir \"绝对路径\" mb_strlen($str,'utf-8');//7 mb_string(变量); 查找并截取函数 strstr(str,substr); 用于在字符串str中查询子字符串substr首次出现的位置，并截取到最后一个字符 strrchr(str,substr); 用于在字符串str中查询子字符串substr最后一次出现的位置，并截取到最后一个字符 查找 strpos(str,substr); 用于在字符串str中查询子字符串substr首次出现的位置 strrpos(str,substr); 用于在字符串str中查询子字符串substr最后一次出现的位置 分割 explode(分割符,str); 将指定的分割符分割字符串str，并返回有每一部分组成的数组 替换 str_replace(search,rep,str); 在字符串str中，查找search部分，并替换成rep，返回新字符串 大小写转换 strtoupper($str); strtolower($str); 去除指定字符 trim(str[,substr]); 用于将字符串str两侧的字符串substr去除，如果substr省略表示去除空格 ltrim(str[,substr]);针对左 rtrim(str[,substr]);针对右 pathinfo pathinfo(path[,option]); path是一个含文件路径的字符串，返回数组 option用于获取路径inxi中指定的部分：PATHINFO_DIRNAME、PATHINFO_BASENAME、PATHINFP_EXTENSION、PATHINFO_FILENAME 用于获取一个文件的路径信息（文件名、文件夹、文件名、扩展名） md5 md5(str); 对于str字符串进行加密，得到32位长度的字符串 htmlspecialchars htmlspecialchars(str); 将字符串中的大于号小于号转换为相应的字符实体 &gt; $img=\"\"; echo $img;//输出图片 $img=htmlspecialchars($img); echo $img;//输出 $img=htmlspecialchars_decode($img);//转换回来 数组 数组的分类 1、索引数组 2、关联数组 数组的创建 1、索引数组的创建 //显示创建 $arr = array(10,20,30,40,50); $arr = [10,20,30,40];//低版本php此法不行 //隐式创建 $arr = array(); $arr[0] = 10; $arr[2] = 30; $arr[1] = 20;//php中数组的下标可以不连续 2、关联数组的创建 $arr = array(键名=>键值,键名=>键值,...); $arr = [键名=>键值,键名=>键值,...];//低版本php此法不行 $arr = array(); $arr['id']=10; //php中，数组元素由键名（下标）和键值组成 数组长度 count($arr); 用于获取数组的长度 数组的指针 current($arr); 用于当前指针所指向的元素的键值 key($arr); 用于当前指针所指向的元素的键名 next($arr); 用于数组的指针下移 prev($arr); 用于数组的指针上移 reset($arr); 用于将数组的指针重置（归位,默认位于第1个元素） end($arr); 用于将数组的指针移到最后一个元素 数组的遍历 1、for循环 是使用循环控制变量来模拟下标的方式来遍历数据，只能遍历连续或有规律的下标（键名） 2、foreach foreach($arr as [$key =>]$value){//$key、$value是一个变量变量名可以自定义 //循环体 }//通过指针遍历 while-each-list遍历 each($arr); each(['id'=>'a','age'=>20]); ================['0'=>'a','id'=>'a','1'=>20,'age'=>20] 将数组arr的一个元素，放入一个由索引和键名两种格式组成的新数组 list(); list($k,&v)=[0=>'hello',1=>'world']; 将hello赋值给k；world赋值给v 数组操作常用的函数 获取数组元素的键名和键值 array_keys(); 获取数组元素所有键名，返回数组 array_values(); 获取数组元素的所有键值，返回数组 判断键名与键值是否存在 array_key_exists(key,array); 判断某个键名是否存在数组中，存在返回true in_array(value,array); 判断某个键值是否存在与数组中，存在返回true isset($arr['key']); 不仅可以用来判断是否存在键,还可以用来判断变量是否存在 数组的追加 array_push(); $arr[] = 'new value'; 数组的合并 array_merge(array1,array2,...); 数组的排序 sort(); 按数组的键值进行升序排序 rsort(); 按数组的键值进行降序排序 extract 用于解压数组，关联元素转换为以键名为变量名的变量，转换不成功就不转换（数字不能做变量名） 排序算法 冒泡排序 $arr=[20,215,0,5,151,522,1]; $len=count($arr); for($i=1;$i$arr[$j+1]){ $tmp=$arr[$j]; $arr[$j]=$arr[$j+1]; $arr[$j+1]=$tmp; } } } 插入排序 $arr=[20,215,0,5,151,522,1]; $len=count($arr); for($i=1;$i=0;$j--){ if($arr[$j]>$arr[$j+1]){ $arr[$j+1]=$arr[$j]; $arr[$j]=$target; } } } 查找算法 顺序查找法 按顺序一个个比较 二分查找法 前提：数组一定要有序且元素不能重复 function findNum($search,$arr){ $l=0; $r=count($arr)-1; while($l$arr[$m]){ $l=$m+1; }else if($search "},"PHP/demos.html":{"url":"PHP/demos.html","title":"PHP 样例","keywords":"","body":"数据渲染 表单处理 状态保持 表单处理 接收并校验 持久化 响应 ?id=\" post方式提交表单附带url参数的方式 如果表单中有文件域,必须设置一下几点 1 method=\"post\" enctype=\"multipart/form-data\" 2 php用$_FILES获取 3 $_FILES['img'] =$avatar;//上传文件的name是img 4 $avatar['error']==UPLOAD_ERR_OK 代表上传成功 5 move_uploaded_file($avatar['tmp_name'],'./uploads' . $avatar['name']);保存文件,可以根据返回值判断是否保存成功；保存数据的文件记录的路径一定要以绝对路径保存,文件操作用相对路径 ---- autocomplete=\"off\" 关闭显示填充历史记录 --> 用户名 性别 男 女 密码 篮球 足球 地球 登录 php.ini中post_max_size配置 让服务端可以接受更大的请求体体积 php.ini中upload_max_filesize配置 让服务端支持更大的单个上传文件 header函数 JSON //HTTP只能传递字符串，数组等类型数据不能传递，服务端要返回结构化数据一般转为json格式的字符串给客户端 //json是数据的表述手段,不是存储手段 //1 json 中 属性名称必须用双引号包裹 //2 json 中 字符串必须用双引号包裹 //3 json 中 不允许使用注释 //4 json 没有undefined PHP操作MySQL // 查询数据的查询语句 // 1. 建立与数据库服务器之间的连接 $connection = mysqli_connect('127.0.0.1', 'root', '123456', 'demo2'); // 1. 必须在查询数据之前 // 2. 必须传入连接对象和编码 mysqli_set_charset($connection, 'utf8'); //或 mysqli_query($connection, 'set names utf8;'); if (!$connection) { // 连接数据库失败 exit('连接数据库失败'); } // 基于刚刚创建的连接对象执行一次查询操作 //id是唯一的，但是where是全表检索，加上limit 1使数据库找到就返回 $query = mysqli_query($connection, \"select * from users where id={$id} limit 1;\"); if (!$query) { exit('查询失败'); } // 遍历结果集 while ($row = mysqli_fetch_assoc($query)) { var_dump($row); } // 释放查询结果集 mysqli_free_result($query); // 炸桥 关闭连接 mysqli_close($connection); // 增删改数据的查询语句 // 1. 建立与数据库服务器之间的连接 $connection = mysqli_connect('127.0.0.1', 'root', '123456', 'demo2'); if (!$connection) { // 连接数据库失败 exit('连接数据库失败'); } // 基于刚刚创建的连接对象执行一次查询操作 $query = mysqli_query($connection, 'delete from users where id = 5;'); if (!$query) { exit('查询失败'); } // 如何拿到受影响行 // 传入的一定是连接对象 $rows = mysqli_affected_rows($connection); var_dump($rows); // 炸桥 关闭连接 mysqli_close($connection); 当从数据库获取中文为\"?\"时 //从MySQL数据库获取到的中文为\"?\"时设置字符集 $connection = mysqli_connect('127.0.0.1', 'root', '123456', 'demo2'); // 1. 必须在查询数据之前 // 2. 必须传入连接对象和编码 mysqli_set_charset($connection, 'utf8'); // 或mysqli_query($connection, 'set names utf8;'); $query = mysqli_query($connection, 'select * from users;'); Http 状态码 状态码 类别 原因短语 1XX Informational(信息性状态码) 接受的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务端错误状态码) 服务器处理请求出错 Cookie // 只传递一个参数是删除 // 原理：设置过期时间为一个过去时间 setcookie('key'); // 传递两个参数是设置 cookie setcookie('key1', 'value1'); // 传递第三个参数是设置过期时间 // 不传递就是 会话级别的 Cookie （关闭浏览器就自动删除） setcookie('key2', 'value2', time() + 1 * 24 * 60 * 60); //path=>设置cookie作用路径范围 /users设置只能在users目录下路径才能访问 setcookie('key3', 'value3', time() + 1 * 24 * 60 * 60, '/users'); //domain 设置cookie的作用域名范围，所有...的子域都能访问到 第二个空字符串 //secure false 代表不是只能https才能访问 true代表只有https才可以用 //httponly true只在发生http时使用，js中访问不到（document.cookie) setcookie('key4', 'value4', time() + 1 * 24 * 60 * 60, '', '', false, true); //获取cookie var_dump($_COOKIE); Cookie进阶版 session：基于cookie基础之上的手段 //相当于给用户的cookie是钥匙，数据存在服务器内，用户通过cookie访问获得实际数据 //找一个当前访问者的箱子，如果没有就创建新箱子，并且把箱子的钥匙（session_id）交给用户（cookie） session_start(); $_SESSION['num'] = $num;//存 $_SESSION['num'];//取，不管是存还是取都要有session_start(); unset($_SESSION['num']);//清空 "},"PHP/WebsiteProcess.html":{"url":"PHP/WebsiteProcess.html","title":"建站流程","keywords":"","body":"开发动态网站应用程序流程 1、需求分析 那些功能，那些业务XMind 2、原型设计 axure rp | 墨刀：快速原型设计工具 3、UI设计 \"草稿\"转换为设计稿，并提供相应产物（设计稿、静态页面）PS | AI | Sketch 4、技术选型 数据库技术栈、后端技术栈、前端技术栈 5、数据库设计 根据业务需要设计数据库的结构 6、项目架构设计 搭框架，创建基本的项目结构、编写基础的公共模块代码和组织代码 7、业务迭代开发 基于项目架构完成各项业务功能 8、集中测试 将所有功能模块整合到一起，集中测试业务功能是否有BUG 9、部署上线 部署到服务器上 管理后台登录 Tips： //从MySQL数据库获取到的中文为\"?\"时设置字符集 $connection = mysqli_connect('127.0.0.1', 'root', '123456', 'demo2'); // 1. 必须在查询数据之前 // 2. 必须传入连接对象和编码 mysqli_set_charset($connection, 'utf8'); // 或mysqli_query($connection, 'set names utf8;'); $query = mysqli_query($connection, 'select * from users;'); //定义函数名时要注意函数名不能和内置函数重名（内置1000+函数），一般在定义的函数名前面加上项目名作为前缀 //判断函数是否定义 //JS typeof fn ==='function' //PHP function_exists('get_current_user'); //被引入的文件要注意的问题 //1、以引入者为当前文件路径考虑 require_once '../functions.php'; //2、以物理路径 拼接 require_once dirname(__FILE__) . '/../../functions.php'; 数据转图表 1、chartjs 2、echarts百度 //sql注入 传入?id=1 or 1 = 1 $id=$_GET['id']; baixiu_execute('delete from categories where id ='.$id); //==>delete from categories where id = 1 or 1 = 1 ==>delete from categories //解决办法 $id=(int)$_GET['id']; //数据库可以联合查询 $posts = baixiu_fetch_assoc_all('select posts.id, posts.title, users.nickname as user_name, categories.name as category_name, posts.created, posts.status from posts inner join categories on posts.category_id = categories.id inner join users on posts.user_id =users.id where 1=1 and posts.status ='public' order by posts.created desc limit 0,20;'); //inner join 关联数据表 on 原表值=关联表值 //order by 根据xx排序 desc降序 asc升序 //limit 0,20 越过0条取20条 //跳转回原来的页面 //http中的referer用于标识当前请求的来源 header('Location: ' . $_SERVER['HTTP_REFERER']); 富文本编辑器 //UEditor百度研发 //CKEditor //TinyMCE //SimpleMDE Markdown编辑器 //浏览器API document.body.contentEditable=true|false;//可编辑 document.execCommand();//加粗、倾斜...命令 ajax 分页功能拓展插件 // twbs-pagination function loadPageData(page){ $('tbody').fadeOut() $.getJSON('/admin/api/comments.php',{page:page},function(res){ $('.pagination').twbsPagination({ totalPages:res['total_page'], visiablePages:5, //设置第一次初始化时不触发onPageClick函数，默认触发 initiateStartPageClick:false, onPageClick:function(e,page){ loadPageData(page) } }) var html = $('#comments_tmpl').render({comments:res['comments']}) $('tbody').html(html).fadeIn() }) } //css loading样式 loading.io loading.awesomes.cn 删除 //事件委托 因为创建元素在元素绑定事件之前 // 有一个bug 点击删除自动重新加载 //原因是a标签没href=\"\"含义是重新加载页面，应该href=\"javascript:;\" $('tbody').on('click','.btn-delete', function () { var $tr = $(this).parent().parent() var id = $tr.data('id') $.get('/admin/api/comment-delete.php', { id: id }, function (res) { if (!res) return loadPageData(currentPage) }) }) 异步文件上传 .form-image { position: relative; background-color: #fff; } $('#logo').on('change',function(){ var $this=$(this) var files=$this.prop('files') if(!files.length) return var file=files[0] //FormDate 是HTML5中新增的 专门配合AJAX操作 用于在客户端与服务端传递二进制数据 var data = new FormDate() data.append('avatar',file) var xhr = new XMLHttpRequest() xhr.open('POST','/admin/api/upload.php') xhr.send(data) xhr.onload=function(){ $this.siblings('img').attr('src',this.responseText) $this.siblings('input').val(this.responseText) } }) "},"Tools/":{"url":"Tools/","title":"工具、插件","keywords":"","body":"Tools 前端开发使用到的插件、工具 utils git webpack element-ui D3_v5 SVG Bootstrap vim markdown 其他工具 "},"Tools/utils.html":{"url":"Tools/utils.html","title":"utils","keywords":"","body":"一维数组转树形结构 const list = [ { id: 14, name: \"米莎\", parentId: 2 }, { id: 2, name: \"猎人\", parentId: 1 }, { id: 13, name: \"雷欧克\", parentId: 2 }, { id: 3, name: \"法师\", parentId: 1 }, { id: 15, name: \"法力浮龙\", parentId: 3 }, { id: 1, name: \"炉石传说\", parentId: 0 }, { id: 4, name: \"战士\", parentId: 1 }, { id: 16, name: \"血吼\", parentId: 4 } ] // 数组转 树结构 function List2Tree(list) { this.tree = []; this.list = list; this.tempMap = new Map(); // 获取树结构片段 返回以该 id 为根元素的 树 this.findChildren = id => { const childTree = []; const tobeDelete = [] this.list.forEach((item, index) => { if (item) { // 找到子元素 if (item.parentId === id) { tobeDelete.push(item.id)// 找到父级的将会被删除 // 如果已经 递归过子元素 if (this.tempMap.has(item.id)) { childTree.push({ ...item, children: this.tempMap.get(item.id) }); this.tempMap.delete(id); } else { childTree.push({ ...item, children: this.findChildren( item.id, this.list.slice(0, index).concat(this.list.slice(index + 1)) ) }); } } } }); // 缓存递归结果 this.tempMap.set(id, childTree); // 去掉可删除的元素 this.list = this.list.filter(item => !tobeDelete.includes(item)); return childTree; }; // 拼接成树 this.splice2Tree = node => { let tempTree = { ...node, children: this.findChildren(node.id) }; const isRoot = this.list.filter(item => item.id === node.parentId); if (isRoot.length === 0) { this.tree = tempTree; } else { this.tempMap.set(tempTree.id, tempTree.children); this.splice2Tree(isRoot[0]); } }; // 获取树 this.getTree = () => { this.splice2Tree(this.list[0]); const secRoot = this.tree this.tempMap.set(secRoot.id, secRoot.children); return this.findChildren(secRoot.parentId); }; } const obj = new List2Tree(list) const treeData = obj.getTree() console.log(JSON.stringify(treeData, null, 2)); "},"Tools/git.html":{"url":"Tools/git.html","title":"git","keywords":"","body":"commit 规范 feat : 新功能 fix : 修复bug docs : 文档改变,修改文档 style : 代码样式改变,格式修改，不影响代码逻辑，注意不是 css 修改 refactor：重构（即不是新增功能，也不是修改bug的代码变动） perf : 性能优化 test：增加修改测试用例 build : 改变了build工具 如 grunt换成了 npm revert : 撤销上一次的 commit chore：构建过程或辅助工具的变动，其他修改, 比如构建流程, 依赖管理 ed: 某个已有功能修改 deps: 升级依赖 scope: commit 影响的范围, 比如: route, component, utils, build... subject: commit 的概述 body: commit 具体修改内容, 可以分为多行 footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接. // 推荐以动词开头，如： 设置、修改、增加、删减、撤销等 git 步骤 # 创建并切换到新分支 git checkout -b feature/reviewStyle # 删除分支 git branch -D feature/reviewStyle # 合并 git pull git merge origin/develop # git stash save git stash pop git add . git commit -m 'feat:创建折线图组件和mock数据文件' git push origin feature/charts # http://git.dataexa.com:83/insight/Insight-View/data-center/merge_requests/new?merge_request%5Bsource_branch%5D=feature%2Fcharts 发起合并请求 git clone git clone -b dev_jk http://10.1.1.11/service/tmall-service.git # 选择分支下载 本地与远程的差集 :（显示远程有而本地没有的commit信息） git log master..origin/master 统计文件的改动 # git diff / git diff --stat master origin/master git diff --cached # 查看要提交的内容； 查看 git add 的内容 git diff # 会显示已做出但未添加到索引的任何更改；查看未 git add 的内容 git status # 获得情况的简要摘要 git reset 回退 commit git reset --hard head^ #回滚到上一个commit git push origin feature-xx --force #命令强制提交到远程仓库 git reset --soft HEAD^ # 撤销上一个commit git stash show -p # 查看某个stash具体内容 cherry-pick git cherry-pick # Cherry pick 支持一次转移多个提交。 同步远程分支 git fetch origin temp:temp # 拉取远程库temp分支的代码到本地的temp分支，如果不存在temp分支，将自动创建temp分支 worktree 工作树 git worktree add ../the_project_2 # 创建一个新的工作树 update-index 忽略文件更改 git update-index --skip-worktree /path/to/file # 忽略这些文件的本地修改 git update-index --no-skip-worktree /path/to/file # 把已经忽略掉的文件再恢复回来 git ls-files -v | grep -i ^S # 查看被忽略的文件项目 强制替换本地文件 git fetch --all # git fetch从远程下载最新的，而不尝试合并或rebase任何东西 git reset --hard origin/master #将主分支重置为您刚刚获取的内容 git pull "},"Tools/webpack.html":{"url":"Tools/webpack.html","title":"webpack","keywords":"","body":"介绍 是什么 打包工具 JavaScript 模块打包之后就可以运行在浏览器 能做什么 JavaScript 资源打包 css 打包 图片打包 less sass babel EcmaScript 6 转 EcmaScript 5 开发工具：http 服务器 代码改变，自动刷新浏览器 压缩代码 官方指南 起步 安装 全局安装： npm install --global webpack 把 webpack 安装到本地项目中，这样项目到哪，webpack 就跟到哪（打包工具随项目走） 开发依赖(--save-dev)，webpack 只是一个打包工具，项目如果上线，上线的是打包结果，而不是这个工具，所以为了区分核心包依赖和开发工具依赖，通过 --save 和 --save-dev 区分 本地安装（推荐）： npm install --save-dev webpack 对于安装到项目中的 webpack 需要配置 package.json 中的 script { \"name\": \"blog\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"app.js\", \"scripts\": { \"a\": \"node ./src/a.js\", \"start\": \"node ./src/main.js\", \"build\": \"webpack\", // 监视编译，使用该命令时，源代码一改，自动编译 \"watch-build\": \"webpack --watch\" // 相当于给命令起别名 }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"art-template\": \"^4.13.2\", } } 然后通过 npm run 命令使用 webpack npm run a # start 比较特殊，可以不加 run npm start # 打包构建 # 这里使用的 webpack 就是项目中安装的 webpack npm run build hello world 全局安装： npm install --global webpack 准备目录结构： . ├── index.html ├── main.js └── foo.js 打包： webpack 模块入口文件 模块出口文件路径 最后记得把 index.html 文件中的脚本应用改为打包后的结果文件路径 划分 src 和 dist 目录： 把源码存储到 src 目录 把打包的结果存储到 dist 目录 配置文件 webpack.config.js 基本配置：在项目根目录下创建 webpack.config.js // 该文件最终是在 Node 环境下执行的 const path = require('path') // 导出一个具有特殊属性配置的对象 moudle.exports = { entry: './src/main.js', // 入口文件模块路径 output: { path: path.join(__dirname, './dist/'), // 出口文件模块所属目录，path 必须是绝对路径 filename: 'bundle.js' // 打包的结果文件名称 } } 打包： # webpack 会自动读取 webpack.config.js 文件作为默认的配置文件 # 也可以通过 --config 参数手动指定配置文件 webpack 打包 JavaScript 模块 JavaScript 模块化 AMD Require.js CMD Sea.js CommonJS 以上都是民间搞出来的，所以在 2015 年的EcmaScript 6 中官方就发布了官方的模块规范：EcmaScript 6 Module 模块规范 推荐在项目中使用 EcmaScript 6 模块规范 以后的趋势统一 webpack AMD CMD CommonJS EcmaScript 6 Module EcmaScript 6 模块规范 导入 import（require） 导出 export（module.exports） 导出默认成员： // 默认成员只能有一个 export default 成员 加载默认成员： // 如果没有 default 成员，则加载到 undefined import xxx from '模块标识' 导出多个成员： // export 必须引用到内部的一个成员 export const a = 123 export const b = 'hello' export function fn () { console.log('hi') } // 也可以 注意：这里不是对象的简写方式，这是导出的特殊方法 export { a, b, fn } 按需加载指定的多个成员： import {a, b} from '模块标识' 一次性加载所有的导出成员： // 包含 default import * as xxx from '模块标识' 资源管理 webpack 不仅可以打包 JavaScript 模块，设置可以把网页的一切资源都当作模块处理 需要结合插件来实现，这些插件被称为 loader（加载器） Loading CSS 安装依赖： # css-loader 的作用是把 css 文件转为 JavaScript 模块 # style-loader 的作用是动态创建 style 节点插入到 head 中 npm install --save-dev style-loader css-loader 配置 webpack.config.js 文件 module.exports = { + module: { + rules: [ + { + test: /\\.css$/, + use: [ + 'style-loader', + 'css-loader' + ] + } + ] + } }; 打包： npm run build 打包 css 也是 把 CSS 文件内容转换成一个 JavaScript 模块，然后再运行 JavaScript 的时候，会动态的创建一个 style 节点插入到 head 头部 Loading Images 安装依赖： npm install --save-dev file-loader 配置 webpack.config.js 文件： module.exports = { module: { rules: [{ + test: /\\.(png|svg|jpg|gif)$/, + use: [ + 'file-loader' + ] }] } }; Loading Fonts Loading Data Loading Less 安装依赖： # 需前置 css-loader style-loader npm install --save-dev less-loader less 配置 webpack.config.js 文件： // webpack.config.js module.exports = { ... module: { rules: [{ test: /\\.less$/, use: [ \"style-loader\", // creates style nodes from JS strings \"css-loader\", // translates CSS into CommonJS \"less-loader\", // compiles Less to CSS ] }] } }; 打包： Loading Sass transpiling JavaScript babel https://babeljs.io/ babel 是一个 JavaScript 编译器，可以把 EcmaScript 6 编译成 EcmaScript 5 babel 可以独立使用，但是独立使用没有意义，一般是和 webpack 结合使用 安装依赖： npm install --save-dev babel-loader babel-core babel-preset-env webpack 配置 webpack.config.js 文件： module: { rules: [ { test: /\\.js$/, exclude: /(node_modules|bower_components)/,// 不转换 node_modules 中的文件模块 use: { loader: 'babel-loader', options: { // babel-preset-env 的最后一个词，转码规则 presets: ['env'] } } } ] } babel-polyfill 默认 babel 只转换语法 可以使用 babel-polyfill 来转换 EcmaScript 6 中的 API 安装依赖： npm install --save @babel/polyfill 配置 webpack.config.js ： module.exports = { // js 入口主文件 entry: [\"@babel/polyfill\", \"./src/main.js\"], }; 这样的话，就会在打包的结果中提供一个垫胶片用以兼容低版本浏览器中不支持的 API transform-runtime 用以解决代码重复问题 在打包过程中，babel 会在某些包提供一些的工具函数，而这些工具函数可能出现重复的出现在多个模块，这样的话就会导致打包体积过大 安装依赖： npm install babel-plugin-transform-runtime --save-dev npm install babel-runtime --save 配置 webpack.config.js： rules: [ // 'transform-runtime' 插件告诉 babel 要引用 runtime 来代替注入。 { test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'], + plugins: ['@babel/transform-runtime'] } } } ] 加入缓存节省编译时间 babel 编译是非常耗时的，我们可以通过开启对编译结果的缓存来提高打包速度： module: { rules: [ { test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { // 默认把打包的结果缓存到 node_modules/.cache 文件 + cacheDirectory: true, presets: ['env'], plugins: ['transform-runtime'] } } } ] } 输出管理 HtmlWebpackPlugin 打包结束后，如果 index.html 在根目录直接运行的话，那么图片资源这些路径就无法访问到。 解决方案就是把 index.html 一起打包放到 dist 目录中 可以使用插件 html-webpack-plugin 而且可以自动添加打包 js 等的文件 bundle.js 路径到打包后的 index.html 文件中 安装依赖： npm install --save-dev html-webpack-plugin 配置 webpack.config.js 文件： const path = require('path'); + const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: { app: './src/index.js', print: './src/print.js' }, // 自动在 index.html 中引入 script 链接 // 而且引用的资源名称，取决于你的 bundle叫什么 + plugins: [ + new HtmlWebpackPlugin({ + template: 'index.html',// 模板文件 + title: 'Output Management' + }) + ], output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') } }; Development 开发 Source maps webpack-dev-server 功能：监视代码改变，自动打包，打包完毕后自动刷新浏览器 安装依赖： npm install --save-dev webpack-dev-server 配置 webpack.config.js 文件： module.exports = { + devServer: { // 配置 webpack-dev-server 的 www 目录 // webpack-dev-server 为了提高打包效率，它把文件存储在了内存中 // 所以打包结果运行在项目根目录的 虚拟目录 中 + contentBase: './' + } }; 配置 package.json 的script { \"name\": \"development\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"webpack.config.js\", \"scripts\": { \"build\": \"webpack\", \"watch-build\": \"webpack --watch\", + \"dev\": \"webpack-dev-server --open\", } } 启动开发模式： npm run dev 该工具会自动帮你打包，打包完毕会自动开启一个服务器，默认监听 8080 端口号，同时自动打开浏览器，接下来就会监视代码的改变，然后自动编译，编译完毕，自动刷新浏览器 Hot Module Replacement 热更新 配置 webpack.config.js 文件： + const webpack = require('webpack'); module.exports = { entry: { + app: './src/index.js' }, devtool: 'inline-source-map', devServer: { contentBase: './dist', + hot: true }, plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin({ title: 'Hot Module Replacement' }), + new webpack.HotModuleReplacementPlugin() ], }; Vue Loader 打包 .vue 单文件组件的 vue-loader vue-template-compiler 安装依赖： npm install --save-dev vue-loader vue-template-compiler 配置 webpack.config.js 文件： // webpack.config.js const VueLoaderPlugin = require('vue-loader/lib/plugin') module.exports = { ... module: { rules: [{ test: /\\.vue$/, use: [ 'vue-loader' ] }] }, plugins: [ new VueLoaderPlugin() ] }; externals 配置 webpack 不打包第三方包 通常情况下我们不打包第三方包，因为第三方包太大，和 bundle 打包到一起会造成资源体积过大，所以还是通过 script 标签的方式把第三方资源引入到页面中 下载第三方包 npm install jquery 在页面中引入资源 配置 webpack.config.js module.exports = { ... externals:{ // key 是第三方包名，value 是全局中的 jQuery 对象 // 这里配置的含义是：当你在代码中 import jquery 时，不会把 jquery 打包到 bundle 中，而是使用用户指定的全局中的 jQuery 对象 jquery: \"jQuery\" } } 加载使用 import $ from 'jquery' $('#app',{ width:200 }) 打包测试 npm run build --save 和 --save-dev 的区别 我们把开发工具相关的依赖信息保存到 devDependencies 选项中，把核心依赖（例如 vue）的依赖信息保存到 dependencies 选项中 这样做的话，就是把开发依赖和核心依赖分开了，因为开发依赖在打包结束之后上线的话就不需要了 最后项目上线，我们真正需要安装的是 dependencies 依赖项的包，可以通过以下命令安装 npm install --production vue-webpack-starter 在模块化环境中使用 vue-router 下载 npm i vue-router 引用资源 配置 webpack.config.js externals:{ 'vue-router': 'VueRouter' } 在 router.js 文件中加载使用 import VueRouter from 'vue-router' import Foo from './components/Foo.vue' import Bar from './components/Bar.vue' // 这里直接默认导出 new 出来的 router 实例 export default new VueRouter({ routes: [ { path: '/foo', component: Foo }, { path: '/bar', component: Bar } ] }) 在 main.js 文件中配置使用路由对象 import Vue from 'vue' import App from './App.vue' + import router from './router' new Vue({ components: { App }, // 自动将 id 为 app 的标签替换成 template: '', router }).$mount('#app') 在 App.vue 中设置路由出口 根组件 Foo Bar + 引入 bootstrap 样式库 安装 npm i bootstrap 引入到 index.html 浏览器报错显示 源代码行号 更改 webpack.config.js // 默认显示 bundle.js 的行号 // 加上 devtool: 'inline-source-map', VueCLi Vue 作者考虑到新手使用 webpack 带来的复杂度，所以官方开发了一个工具： vue-cli 。它可以帮你快速生成一个已经配置好了的 webpack 项目 crumb 1、npm 包的vue 项目入口文件在 src/index.js 2、不会加载 模块内的 vue.config.js 、 .env.development 等 "},"Tools/element-ui.html":{"url":"Tools/element-ui.html","title":"element-ui","keywords":"","body":"element ui 官网 elelment ui 安装： npm i element-ui -S 配置： bugs form validate-on-rule-change 只会校验 rules 的变化，不会监听 form-item 写的 rule 的变化 validateField 执行后不会清空报错状态 table 自定义表头 如果没有写 slot-scope=\"scope\"，表头里数据变化，不会重新渲染 "},"Tools/D3_v5.html":{"url":"Tools/D3_v5.html","title":"D3_v5","keywords":"","body":"相关文档 官方 API 中文手册 中文手册 中文API 基本使用 // HTML // // // ES6 import {scaleLinear} from \"d3-scale\"; import * as d3 from \"d3\"; // Node var d3 = require(\"d3\"); 选择元素 d3.select() // 选择第一个 d3.selectAll() // 选择所有 // e.g. var body = d3.select(\"body\");//选择文档中的body元素 var p = body.selectAll(\"p\");//选择body中所有的p元素 绑定数据 data()：将一个数组绑定到选择集上，数组各项和选择集各元素绑定，也就是一一对应的关系 datum()：将一个数据绑定到所有选择集上 dog cat pig // datum() var str = \"is an animal\";//新建一个字符串 var p = d3.select(\"body\") .selectAll(\"p\"); p.datum(str)//绑定 .text(function(d,i){ return \"第\"+i+\"个元素\"+d; }); // data() var dataset = [\"so cute\",\"cute\",\"fat\"]; var p = d3.select(\"body\").selectAll(\"p\"); p.data(dataset).text(function(d,i){ return \"第\"+i+\"个动物\"+d; }); Update、Enter、Exit update和enter：数组[3,6,9,12,15]绑定到三个上。可以想象到，数组的最后两个元素没有可以绑定的元素，这时D3会建立两个空的元素与数组最后的两个数据相对于，那么这部分就称为Enter。而有元素与数据对应的部分就称为Update exit：如果数组[3]绑定到三个上，可以想象，最后两个没有可绑定的数据，那么没有数据绑定的部分就称为Exit Enter、Update dog cat pig // enter var dataset = [3,6,9,12,15]; var p = d3.select(\"body\").selectAll(\"p\"); var update = p.data(dataset)//绑定数据,并得到update部分 var enter = update.enter();//得到enter部分 //下面检验是否真的得到 //对于update的处理 update.text(function(d,i){ return \"update: \"+d+\",index: \"+i; }) //对于enter的处理 //注意，这里需要先添加足够多的，然后在添加文本 var pEnter = enter.append(\"p\")//添加足够多的 pEnter.text(function(d,i){ return \"enter: \"+d+\",index: \"+i; }) Exit、Update dog cat pig rat var dataset = [3,6]; var p = d3.select(\"body\").selectAll(\"p\"); var update = p.data(dataset)//绑定数据,并得到update部分 var exit = update.exit();//得到exit部分 //下面检验是否真的得到 //对于update的处理 update.text(function(d,i){ return \"update: \"+d+\",index: \"+i; }) //对于exit的处理通常是删除 ，但在这里我并没有这么做 exit.text(function(d,i){ return \"exit\"; }) 选择、插入、删除元素 dog cat pig rat // 选择元素 /** .select() .selectAll() */ var p = d3.select(\"body\").select(\"p\");// 选择第一个 p p.style(\"color\",\"red\"); // 插入元素 /** .append()：在选择集尾部插入元素 .insert()：在选择集前面插入元素 */ var p = d3.select(\"body\").append(\"p\").text(\"another animal\").style(\"color\",\"red\"); // 删除元素 /** .remove() */ var p = d3.select(\"body\").select(\"#myP3\").remove() 绘制图标 svg画布：svg绘制的是矢量图（还有canvas画布，这个是JavaScript用来绘制2D图像的，是位图） rect元素：是d3中在svg中绘制矩形的元素 g元素：分组的时候使用 1、数据准备 var marge = {top:60,bottom:60,left:60,right:60}//设置边距 var dataset = [ 250 , 210 , 170 , 130 , 90 ]; //数据（表示矩形的宽度） ​ 2、得到svg画布，并创建分组 var svg = d3.select(\"svg\");//得到svg画布 var g = svg.append(\"g\")//定义一个用来装整个图表的一个分组，并设置他的位置 .attr(\"transform\",\"translate(\"+marge.top+\",\"+marge.left+\")\");// .attr(xxxx)是用来设置属性的，而这里的“transform”是用来设置位置， 3、画出矩形 var rectHeight = 30;//设置每一个矩形的高度 g.selectAll(\"rect\") .data(dataset) .enter() .append(\"rect\") .attr(\"x\",20)//设置左上点的x .attr(\"y\",function(d,i){//设置左上点的y return i*rectHeight; }) .attr(\"width\",function(d){//设置宽 return d; }) .attr(\"height\",rectHeight-5)//设置长 .attr(\"fill\",\"blue\");//颜色填充 比例尺 线性比例尺 序数比例尺 线性比例尺 // domain域和range域都可以连续变化 var dataset = [1.2, 2.3, 0.9, 1.5, 3.3]; var min = d3.min(dataset);//得到最小值 var max = d3.max(dataset);//得到最大值 var scaleLinear = d3.scaleLinear().domain([min,max]).range([0,300]);// [0.9,3.3]映射[0,300] document.write(\"scaleLinear(1)输出：\"+scaleLinear(1)); 序数比例尺 // domain域和range域是离散的，也就是数组 var index = [0,1,2,3,4]; var color = [\"red\",\"blue\",\"yellow\",\"black\",\"green\"]; var scaleOrdinal = d3.scaleOrdinal().domain(index).range(color);// .range(color);建立一个序数比例尺 document.write(\"scaleOrdinal(1)输出：\"+scaleOrdinal(1)); 坐标轴 为了表绘制一个坐标轴，我们还是需要以下新的知识点 call()函数 //为坐标轴定义一个线性比例尺 var xScale = d3.scaleLinear().domain([0,d3.max(dataset)]).range([0,250]); //定义一个坐标轴 var xAxis = d3.axisBottom(xScale)//定义一个axis，由bottom可知，是在下面的 .ticks(7);//设置刻度数目 g.append(\"g\") .attr(\"transform\",\"translate(\"+20+\",\"+(dataset.length*rectHeight)+\")\") .call(xAxis);// 将新建的分组传给xAxis()函数，用以绘制，所以这句代码等价于 xAixs (g.append(\"g\") ) ; 图表 d3.scaleBand()：这也是一个坐标轴，可以根据输入的domain的长度，等分rangeRound域（类比range域） d3.range()：这个比较复杂，建议去看百度（或者官方API），在这里我只讲一下这个返回一个等差数列 1、得到SVG画布 var marge = {top:60,bottom:60,left:60,right:60} var svg = d3.select(\"svg\");//得到SVG画布 var width = svg.attr(\"width\");//得到画布的宽 var height = svg.attr(\"height\");//得到画布的长 var g = svg.append(\"g\") .attr(\"transform\",\"translate(\"+marge.top+\",\"+marge.left+\")\"); 2、数据集 var dataset = [10,20,30,23,13,40,27,35,20]; 3、分别在x方向和y方向绘制坐标轴 var xScale = d3.scaleBand() // 这是一个坐标轴 .domain(d3.range(dataset.length)) .rangeRound([0,width-marge.left-marge.right]); var xAxis = d3.axisBottom(xScale); var yScale = d3.scaleLinear() .domain([0,d3.max(dataset)]) .range([height-marge.top-marge.bottom,0]); var yAxis = d3.axisLeft(yScale); 4、为每个矩形和对应的文字创建一个分组 var gs = g.selectAll(\".rect\") .data(dataset) .enter() .append(\"g\"); 5、绘制矩形 var rectPadding = 20;//矩形之间的间隙 gs.append(\"rect\") .attr(\"x\",function(d,i){ return xScale(i)+rectPadding/2; }) .attr(\"y\",function(d){ return yScale(d); }) .attr(\"width\",function(){ return xScale.step()-rectPadding; }) .attr(\"height\",function(d){ return height-marge.top-marge.bottom-yScale(d); }) .attr(\"fill\",\"blue\"); 6、绘制文字 gs.append(\"text\") .attr(\"x\",function(d,i){ return xScale(i)+rectPadding/2; }) .attr(\"y\",function(d){ return yScale(d); }) .attr(\"dx\",function(){ (xScale.step()-rectPadding)/2; }) .attr(\"dy\",20) .text(function(d){ return d; }) 交互操作 on(\"eventName\",function)；该函数是添加一个监听事件，它的第一个参数是事件类型，第二个参数是响应事件的内容 d3.select(this),选择当前元素 常见的事件类型 click：鼠标单击某元素时触发，相当于mousedown和mouseup的组合 mouseover：鼠标放在某元素上触发 mouseout：鼠标移出某元素时触发 mousemove：鼠标移动时触发 mousedown：鼠标按钮被按下时触发 mouseup：鼠标按钮被松开时触发 dblclick：鼠标双击时触发 查看监听事件 .on(\"click\",function(){ console.log(d3.event); }) 几何图形 直线：line 矩形：rect 圆：circle 折线：polyline { return points.map(item => { return [item.x, item.y].join(',') }).join(' ') }) x0,y0 x1,y1 ... 以空格分割点 --> 多边形：polygon zoom 描边不跟随缩放而缩放 // 在图形上添加属性 vector-effect: non-scaling-stroke this.elementSelection = this.groupSelection .append(\"polygon\") .attr(\"vector-effect\", \"non-scaling-stroke\") 事件 event /** * chrome 和 firefox 的 event.offsetX 不一样 * firefox 旧版本无 offsetX ，新版本的 offsetX 也不一样 * 可以用 layerX 替代 ，但是需要 position:abslute * @param event d3.event */ public output(event) { let x = event.offsetX; let y = event.offsetY; let x let y // firefox if (navigator.userAgent.includes('Firefox')) { x = event.layerX y = event.layerY } // chrome else { x = event.offsetX; y = event.offsetY; } "},"Tools/SVG.html":{"url":"Tools/SVG.html","title":"SVG","keywords":"","body":"[SVG精髓] (https://github.com/xswei/SVG_Essentials) "},"Tools/Bootstrap.html":{"url":"Tools/Bootstrap.html","title":"Bootstrap","keywords":"","body":"栅格系统 title .container{height: 100px;background: pink;} .container > .row{height: 50px;background: green;} .container > .row > div{height: 25px;border: 1px solid #ccc;} 栅格系统的拓展功能 col-xs-3 col-xs-9 响应式工具 组件 collapse 组件 折叠 切换 切换 内容 内容 内容 内容 内容 Brand Link Link Link Link carousel 组件 轮播图 ... ... 轮播图自适应 .pc_imgBox{ display: block; height: 400px; width: 100%; background-size: cover; background-position: center; background-repeat: no-repeat; } .m_imgBox{ display: block; width: 100%; } .m_imgBox img{ display: block; width: 100%; } 插件 Bootstrap FileInput // 初始化 $(\"#upload\").fileinput({ uploadUrl: \"upload\", //上传到后台处理的方法 uploadAsync: false, //设置同步，异步 （同步） language: 'zh', //设置语言 allowedFileExtensions : [ 'jpg','jpeg','png', 'gif' ], allowedFileTypes: ['image', 'video', 'flash'], overwriteInitial: false, //不覆盖已存在的图片 //下面几个就是初始化预览图片的配置 initialPreviewAsData: true, initialPreviewFileType: 'image', initialPreview:path , //要显示的图片的路径 initialPreviewConfig:con, maxFileSize : 1000,//上传文件最大的尺寸 maxFilesNum : 1,//上传最大的文件数量 initialCaption: \"请上传商家logo\",//文本框初始话value }) // 获取上传的返回值 可以连 链式编程 连在上面后面 $('#upload').on('fileuploaded', function(event, data, previewId, index) { var form = data.form, files = data.files, extra = data.extra, response = data.response, reader = data.reader; console.log(response);//打印出返回的json console.log(response.paths);//打印出路径 }) "},"Tools/vim.html":{"url":"Tools/vim.html","title":"vim","keywords":"","body":"Normal 模式 移动 hjkl → 也可以使用光标键 (←↓↑→) 0 → 数字零，到行头 ^ → 到本行第一个不是 blank 字符的位置（所谓 blank 字符就是空格，tab，换行，回车等） $ → 到本行行尾 g_ → 到本行最后一个不是 blank 字符的位置 fa → 到下一个为 a 的字符处(F 相反方向) t, → 到逗号前的第一个字符(逗号可以变成其它字符)(T 相反方向) ngg → 跳转到某行（也可以 : N 到第 N 行，如 :137 到第 137 行） n% → 按百分比转到相应的行数 NG → 到第 N 行 （g 大小写均可） gg → 到第一行 G → 到最后一行 H → 页面顶部 M → 页面中部 L → 页面底部 zz → 将光标所在行调整至页面中间 按单词移动 w → 到下一个单词的开头、 e → 到下一个单词的结尾 最强的光标移动 % → 匹配括号移动 * 和 # → 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个） * → 搜索单词 n 下一个 N 上一个 ctrl+n === :nohl → 回到上一个编辑点 → 回到下一个编辑点 mx → 将当前位置标记为 x 'x → 回到标记点 x '' → 回到上一个标记点，或上下文所在行的开头 `` → 回到上一个标记或上下文的确切位置 快速选中 ci' → 更改配对标点符号中的文本内容（逗号可以变成其它字符） di' → 删除配对标点符号中的文本内容（逗号可以变成其它字符） yi' → 复制配对标点符号中的文本内容（逗号可以变成其它字符） vi' → 选中配对标点符号中的文本内容（逗号可以变成其它字符） 复制、剪切、粘贴 p → 粘贴剪贴板 yy → 拷贝当前行 “+0 → 粘贴上一个 替换操作 # yiw 复制 # 光标移到要替换的单词, viw 选中，再 p 粘贴 删除 dt\" → 删除所有的内容，直到遇到双引号—— \" （可以变成其它字符） cw → 替换从光标所在位置后到一个单词结尾的字符 dw → 删除到下一个单词开头 de → 删除到本单词末尾 dE → 删除到本单词末尾包括标点在内 db → 删除到前一个单词 dB → 删除到前一个单词包括标点在内 dd → 删除当前行，并把删除的行存到剪贴板里 D d$ → 删除光标位置到本行结尾 d0 → 删除光标位置到本行开头 Undo/Redo u → undo → redo 重复操作 . → (小数点) 可以重复上一次的命令 N → 重复某个命令 N 次 联动 # 例如 0y$ 命令意味着： 0 → 先到行头 y → 从这里开始拷贝 $ → 拷贝到本行最后一个字符 # 你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。 # 你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串 # 还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝： d (删除 ) v (可视化的选择) gU (变大写) gu (变小写) 等等 剪切板 \"+y → 复制到剪切板 \"+p → 从剪切板粘贴 标记 m → 定义标记。标记名称为一个字符 ` → 返回标记 宏录制： qa 操作序列 q, @a, @@ qa 把你的操作记录在寄存器 a。 于是 @a 会 replay 被录制的宏。 @@ 是一个快捷键用来 replay 最新录制的宏。 # 示例 # 在一个只有一行且这一行只有“1”的文本中，键入如下命令： qaYpq→ qa 开始录制 Yp 复制行. 增加1. q 停止录制. @a → 在1下面写下 2 @@ → 在2 正面写下3 # 现在做 100@@ 会创建新的100行，并把数据增加到 103. Visual 模式 J → 把所有的行连接起来（变成一行） 或 >> → 左右缩进 = → 自动给缩进 区域选择 命令格式为：a 和 i action 可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。 object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：\"、 '、 )、 }、 ]。 # 假设你有一个字符串 `(map (+) (\"foo\"))`.而光标键在第一个 `o `的位置。 vi\" → 会选择 foo. va\" → 会选择 \"foo\". vi) → 会选择 \"foo\". va) → 会选择(\"foo\"). v2i) → 会选择 map (+) (\"foo\") v2a) → 会选择 (map (+) (\"foo\")) 块操作: 典型的操作： 0 I-- [ESC] ^ → 到行头 → 开始块操作 → 向下移动 (你也可以使用 hjkl 来移动光标，或是使用%，或是别的) I-- [ESC] → I 是插入，插入“--”，按 ESC 键来为每一行生效 在所有被选择的行后加上点东西： 选中相关的行 (可使用 j 或 或是 /pattern 或是 % 等……) $ 到行最后 A, 输入字符串，按 ESC。 Insert 模式 自动提示： 和 你可以输入一个词的开头，然后按 或是，自动补齐功能就出现了 插入模式 a → 在光标后插入(A 行尾插入) i → 光标之前插入( I 行首插入) o → 下一行插入(O 上一行插入) 删除 → 删除前一个字符 → 前一个单词 → 前面一行所有字符 vscode 插件 vim 配置 { \"editor.lineNumbers\": \"relative\", \"vim.easymotion\": true, \"vim.incsearch\": true, \"vim.useSystemClipboard\": true, \"vim.useCtrlKeys\": true, \"vim.hlsearch\": true, \"vim.insertModeKeyBindings\": [ { \"before\": [\"j\", \"j\"], \"after\": [\"\"] } ], \"vim.insertModeKeyBindingsNonRecursive\": [ { \"before\": [\"\"], \"commands\": [\"editor.action.clipboardCopyAction\"] }, { \"before\": [\"\"], \"commands\": [\"editor.action.clipboardPasteAction\"] } ], \"vim.visualModeKeyBindingsNonRecursive\": [ { \"before\": [\"L\"], \"after\": [\"$\"] }, { \"before\": [\"H\"], \"after\": [\"^\"] } ], \"vim.normalModeKeyBindingsNonRecursive\": [ { \"before\": [\"\", \"d\"], \"after\": [\"d\", \"d\"] }, { \"before\": [\"\"], \"commands\": [\":nohl\"] }, { \"before\": [\"K\"], \"commands\": [\"lineBreakInsert\"], \"silent\": true }, { \"before\": [\"L\"], \"after\": [\"$\"] }, { \"before\": [\"H\"], \"after\": [\"^\"] }, { \"before\": [\"\"], \"commands\": [\"workbench.action.navigateLeft\"] }, { \"before\": [\"\"], \"commands\": [\"workbench.action.navigateDown\"] } ], \"vim.leader\": \"\", \"vim.handleKeys\": { \"\": false, \"\": false, \"\": false, \"\": false } } "},"Tools/markdown.html":{"url":"Tools/markdown.html","title":"markdown","keywords":"","body":"二级列表生成 ### (退出源代码码模式下)在 - 前面 按tab 待办列表 - [ ] 不勾选 - [x] 勾选 可展开区域 show more This section was in a detail block "},"Tools/autoHotKey.html":{"url":"Tools/autoHotKey.html","title":"autoHotKey","keywords":"","body":"切换桌面 LWin & PgUp:: Send {LWin Down}{Ctrl Down}{Left}{Ctrl Up}{LWin Up} return LWin & PgDn:: Send {LWin Down}{Ctrl Down}{Right}{Ctrl Up}{LWin Up} return "},"Tools/tools.html":{"url":"Tools/tools.html","title":"其他工具","keywords":"","body":"awesome 技术名称 方便在 github 中查找别人收集好的资源 例如 vue awesome 就有别人收集好的 使用 json-server 来模拟数据接口 参考文档：json-server 该工具默认启动的服务自带跨域能力 这个工具已经在服务端处理了跨域问题，你直接来请求即可 安装： npm i -g json-server 使用： 创建一个 db.json ，写入以下内容： { \"list\":[{ \"id\":1, \"name\":\"jack\", \"age\":18 },{ \"id\":2, \"name\":\"jack\", \"age\":18 },{ \"id\":3, \"name\":\"jack\", \"age\":18 }] } 启动接口服务(该服务默认占用 3000 端口)： json-server --watch db.json 增删改查： GET /list 查询所有 GET /list/id 查询单个 POST /list 添加 DELETE /list/id 根据 id 删除 PATCH /list/id 根据 id 修改 接口测试工具： postman http-server 安装： npm i http-server 查看使用帮助： hs -h 基本使用： # 默认占用 8080 端口启动一个服务器，直接打开浏览器 hs -o # 指定端口 hs -p 3000 -o # 不启用缓存开启 hs -c-1 -p 3000 -o lodash lodash 第三方 JavaScript 工具函数库：提供 函数节流、函数防抖 等辅助函数 官网： loadsh 安装： npm i --save lodash 使用： // 自动添加对象 _ ，使用时 直接 _.函数名 console.log(_) 图片懒加载 主要用于一屏页面比较多时，没滚到时，图片不显示，当滚到特定页面自动加载 安装 npm i vue-lazyload 配置： // main.js import VueLazyload from 'vue-lazyload' Vue.use(VueLazyload,{ loading:\".static/loading-svg/loading-bars.svg\" //图片在static文件夹，就可以直接写路径了 loading: require('../public/loading-svg/loading-bars.svg') //图片在assets文件夹，就需要使用require（）进行引入 }) // vue-lazyload是在 main.js 文件中引入，不会被 webpack 进行编译，src 中的文件会被 webpack 编译，包括 assets ，assets 文件夹中的图片地址，会在编译过程中改变。因此 vue-lazyload 无法正确获得图片地址，就不能显示图片了。 使用： 图片滚动自动加载 vue-infinite-scroll 轮播图插件 swiper 前端开发技术 awesomes 虚拟滚动条 https://github.com/tangbc/vue-virtual-scroll-list https://github.com/Akryum/vue-virtual-scroller 表格 https://github.com/xuliangzhan/vxe-table https://xuliangzhan.com/vxe-table/index.html#/table/excel/cell "},"System/":{"url":"System/","title":"操作系统","keywords":"","body":"操作系统 Linux "},"System/Linux/":{"url":"System/Linux/","title":"Linux","keywords":"","body":"Linux ArchLinux使用手册 "},"System/Linux/archlinux.html":{"url":"System/Linux/archlinux.html","title":"archLinux使用手册","keywords":"","body":"安装 archLinux 参考链接： Arch Linux 安装指南[2018.12.01] / 安装问题 / Arch Linux 中文论坛 Installation guide (简体中文) - ArchWiki) 给 GNU/Linux 萌新的 Arch Linux 安装指南 rev.B - 约伊兹的萌狼乡手札 安装前准备 # 下载 iso 镜像 # 1、插入U盘，df -h 查看U盘文件系统挂载情况，然后使用 umount /dev/sdb* 卸载U盘文件系统； # 2、执行命令：sudo mkfs.xxx /dev/sdb 格式化U盘为 xxx 格式； # 请将xxx换成您需要的文件系统类型，如fat、vfat、ntfs、ext4等等、或者 windows 用户推荐 rufus # 3、dd if=*/*.iso of=/dev/sdb bs=4M (数据块大小，每个数据块只能存一个文件的数据) # 4、执行sync，同步缓存中的数据至U盘 sudo dd bs=4M if=archlinux.iso of=/dev/sdx status=progress && sync 启动安装环境 成功从准备好的安装介质中启动后，屏幕将呈现出一个菜单。请使用 [↑]/[↓]（方向键）进行选择，[↩] （回车键）确认。 BIOS： UEFI： 当屏幕上出现命令行提示符及闪烁的光标时即启动完毕。 设置键盘布局 默认键盘布局为 US（美式键盘）。如需修改键盘布局请使用 loadkeys 命令。如需修改字体请使用 setfont 命令。 网络连接 ArchISO 在启动时会尝试连接网络，可通过命令 ping 查看连接是否已建立。 ping -c 4 www.baidu.com 若网络尚未连接，请先接入网络。若使用 WiFi 连接，请使用 wifi-menu 命令。 若使用 ADSL 宽带连接，请使用 pppoe-setup 进行配置，再使用 systemctl start adsl 进行连接。 刷新本地时间 # timedatectl set-ntp true 配置软件仓库镜像 软件仓库镜像是软件仓库的拷贝副本。Arch Linux 在许多国家和地区都有仓库镜像，但是默认开启了所有仓库镜像，因而用户可能无法充分利用当地网络优势。为了达到最高的下载速度，需调整镜像顺序，提高当地镜像的优先级。 Arch Linux 的仓库镜像地址存于 /etc/pacman.d/mirrorlist，每行一条按使用顺序排序。要让 Arch Linux 的包管理器 pacman 优先使用指定的仓库镜像，只需调整顺序，使之置于前列即可。 # nano /etc/pacman.d/mirrorlist [F6] 搜索 china [方向键] 移动光标至 Server 行 [CTRL+K] 剪切该行 [方向键] 移动光标至其他 Server 行前 [CTRL+U] 粘贴至此行 [CTRL+O] 保存，[回车键] 确定 # 中国大陆用户可使用以下命令选取大陆镜像服务器。 # sed -i '/China/!{n;/Server/s/^/#/};t;n' /etc/pacman.d/mirrorlist 然后用 pacman -Syy 刷新一下软件包数据库 环境检查 启动模式检查 # ls /sys/firmware/efi/efivars 若该目录不存在，则当前是以 BIOS/CSM 模式启动，否则是以 UEFI 模式启动。 分区 分区方案 Arch Linux 要求至少一个分区分配给根目录 /。 在 UEFI 系统上，需要一个 UEFI 系统分区。 实施分区 首先使用 lsblk 或 fdisk -l 确定目标磁盘及目标分区。 # fdisk -l 结果中以 rom，loop 或者 airoot 结束的可以被忽略。 对于一个选定的设备，以下的分区是必须要有的： 一个根分区（挂载在根目录）/； 如果 UEFI 模式被启用，你还需要一个 EFI 系统分区。 如果需要创建多级存储例如 LVM、disk encryption 或 RAID，请在此时完成。 然后使用分区工具如 parted、cfdisk、cgdisk 进行分区。推荐 cfdisk # cfdisk /dev/sdX # sdX 为目标磁盘 新建分区： 1. [↑]/[↓]（方向键）选中 Free space（空闲空间） 2. [←]/[→]（方向键）选中 New 新建分区 3. [←]/[→]（方向键）选中 Type 选择分区类型（默认为 Linux filesystem；对于 EFI 系统分区选择 EFI System） 4. 输入分区大小（默认单位为字节，可以加上后缀K、M、G），[回车键] 确认 写入分区表： 1. [←]/[→]（方向键）选中 Write 2. 输入 yes [回车] 确定写入 分区示例 BIOS 和 MBR#Master_Boot_Record) 挂载点 分区 分区类型 建议大小 /mnt /dev/sd*X*1 Linux 剩余空间 [SWAP] /dev/sd*X*2 Linux swap (交换空间) 大于 512 MiB UEFI with GPT#GUID_分区表) 挂载点 分区 分区类型 建议大小 /mnt/boot or /mnt/efi /dev/sd*X*1 EFI 系统分区) 260–512 MiB /mnt /dev/sd*X*2 Linux x86-64 根目录 (/) 剩余空间 [SWAP] /dev/sd*X*3 Linux swap (交换空间) 大于 512 MiB 分区格式化（创建文件系统） 首先使用 lsblk 或 fdisk -l 确定目标磁盘及目标分区。 # lsblk 然后使用格式化工具进行格式化。本文推荐 EXT4 文件系统，其格式化工具为 mkfs.ext4。 # mkfs.ext4 /dev/sdXY # sdXY 为目标分区 举个例子，如果根分区在 /dev/sd*X*1 上并且会使用 *ext4* 文件系统，运行： # mkfs.ext4 /dev/sdX1 如果您创建了交换分区（例如 /dev/*sda3*），使用 mkswap 将其初始化： # mkswap /dev/sdX2 # swapon /dev/sdX2 如果要格式化新的 EFI 系统分区的话，用 mkfs.vfat 挂载分区 请注意挂载次序。从根目录开始，先挂载父目录，再挂载子目录 # mount 将根分区挂载到 /mnt，例如： # mount /dev/sdX1 /mnt 创建其他剩余的挂载点（比如 /mnt/efi）并挂载其相应的分区。 安装基础包 文件 /etc/pacman.d/mirrorlist 定义了软件包会从哪个 镜像源 下载。在 LiveCD 启动的系统上，所有的镜像都被启用，并且在镜像被制作时，我们已经通过他们的同步情况和速度排序。 在列表中越前的镜像在下载软件包时有越高的优先权。你可以相应的修改文件 /etc/pacman.d/mirrorlist，并将地理位置最近的镜像源挪到文件的头部，同时你也应该考虑一些其他标准。 这个文件接下来还会被 pacstrap 拷贝到新系统里，所以请确保设置正确。 使用 pacstrap 脚本，安装 base 软件包和 Linux 内核以及常规硬件的固件： # pacstrap /mnt base 配置基础系统 生成分区表 用以下命令生成 fstab 文件 (用 -U 或 -L 选项设置UUID 或卷标)： # genfstab -U /mnt >> /mnt/etc/fstab 接着使用 arch-chroot 进入新系统。 # arch-chroot /mnt 时区 # ln -sf /usr/share/zoneinfo/$(tzselect) /etc/localtime # 中国大陆用户使用以下命令。 # ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 硬件时间设置 运行 hwclock(8) 以生成 /etc/adjtime： # hwclock --systohc 本地化设置 进行本地化设置以正确显示本地文字、货币、时间与时期格式以及其它本地相关标准。 编辑 /etc/locale.gen，去掉需要的 locale 的注释（行头的字符 #）。 # nano /etc/locale.gen [F6] 搜索 zh_CN.UTF-8 [←]/[→]（方向键）移动光标至字符 # 处 [DELETE]/[BACKSPACE] 删除字符 # [CTRL+O] 保存，[回车键] 确定 然后使用 locale-gen 生成 locale。 # locale-gen 接着使用以下命令设置默认 locale。 # echo LANG= > /etc/locale.conf # echo 'LANG=zh_CN.UTF-8' > /etc/locale.conf 警告: 不推荐在此设置任何中文 locale，会导致 TTY 乱码。 主机名 # echo > /etc/hostname 接着向 /etc/hosts 文件添加 hosts 条目。 # 127.0.0.1 localhost.localdomain localhost ::1 localhost.localdomain localhost 127.0.1.1 .localdomain 网络连接 考虑到多数用户最终会安装图形化的桌面环境，因而推荐使用兼容性较好 NetworkManager 来管理网络。需要注意的是，当前安装环境已连接至网络，请勿尝试多次连接，而待安装完成并重启后再进行连接。 首先安装 NetworkManager： # pacman -S networkmanager 如果需要图形化的管理工具，以便稍后在桌面环境中使用，可接着安装 nm-connection-editor 如果需要系统托盘工具，可接着安装 network-manager-applet 如果需要 ADSL 支持，需要安装 rp-pppoe 为 root 用户设置密码 # passwd 安装引导程序 引导程序是机器启动后运行的第一个程序，其作用在于加载并启动系统内核。本文推荐安装并介绍如何配置 GRUB 作为引导程序。如需安装其他引导程序 BIOS 系统： # pacman -S grub os-prober # grub-install --target=i386-pc /dev/sdX # sdX 为目标磁盘 # grub-mkconfig -o /boot/grub/grub.cfg UEFI 系统： # pacman -S dosfstools grub efibootmgr # grub-install --target=x86_64-efi --efi-directory= --bootloader-id=GRUB # grub-mkconfig -o /boot/grub/grub.cfg 完成安装 至此，基础可用的 Arch Linux 便安装完毕。现在按下列步骤退出安装环境并重启。 使用命令 exit 或 [CTRL+D] 退回安装环境 卸载新分区： # umount -R /mnt 重启 # reboot 移除安装介质 用户管理 添加用户使用 useradd 命令。具体用法请查看 man 手册或 help 消息。 # useradd -m -g users -s /bin/bash archuser 该命令创建一个名为 archuser 的用户，指定登录 shell 为 bash，所属主用户组 users，并在 /home 下创建同名用户文件夹。 passwd archuser 该命令为用户 archuser 设置密码。 设置 sudo sudo 应该已经作为 base-devel 的一部分装上去了，如果没有的话也可以自己手动安装一下： # pacman -S sudo sudo 的配置文件是 /etc/sudoers ，但是咱们不会直接去编辑它（因为一旦搞坏了不好修）。 所以有一个 visudo 的命令用来代理编辑它（就是先编辑一个临时文件，然后检查有没有错误， 一切 OK 后再覆盖）。 虽然这个文件有很多行，但是咱们还是先从让它能够工作开始来最小的修改它。 找到下面的这一行，然后把 %wheel 前面的注释符号（#）去掉，不过百分号要留下： ## Uncomment to allow members of group wheel to execute any command # %wheel ALL=(ALL) ALL 然后就可以保存退出啦~ （效果就是注释里说明的，给 wheel 组执行所有命令的权限） 如果汝不想每一次都在前面加上 EDITOR 来指定编辑器的话，可以加上这几行： # 重设默认的环境变量 Defaults env_reset # 设置默认的编辑器，并使 visudo 不再读取环境变量 editor 的值。 Defaults editor=/usr/bin/nano, !env_editor 配置图形界面 安装显卡驱动 官方软件软件仓库为主流的显卡提供了驱动包： ### 通用显卡驱动 xf86-video-vesa 是开源的显卡驱动实现，提供了最基本的显示功能。 ### 因特尔显卡驱动 因特尔显卡应当是开箱即用的，不需要安装显卡驱动，但通常建议安装 mesa 以支持 3D 加速。如果需要 Vulkan 支持（需 Ivy Bridge 及更新架构），须安装 valkan-intel。如果需要支持 Xorg 2D 加速，须安装 xf86-video-intel。 然而需要注意的是，安装 xf86-video-intel 与否需要更多斟酌，详见此处)。 ### 英伟达显卡驱动 英伟达显卡驱动有第三方的开源实现 xf86-video-nouveau 和英伟达官方私有驱动 nvidia 系列。 * 对于 GeForce 600 及更新系列（除了 610, 620, 625, 705, 800A 和其他低端重贴牌显卡）请安装 nvidia * 对于 2010 至 2011 年间 GeForce 400/500 请安装 nvidia-390xx * 对于 2006 至 2010 年间 GeForce 8000/9000、ION 和 100-300 系列 [NV5x, NV8x, NV9x and NVAx] 请安装 nvidia-340xx * 更早的显卡系列驱动请查阅此处 如果需要 NVIDIA Optimus 支持，请查阅此处)。 ### AMD/ATI AMD/ATI 显卡驱动原先有开源实现 xf86-video-ati 及闭源实现 AMD Catalyst。而AMD 自统一开源驱动和闭源驱动后又发布了新的开源实现 xf86-video-amdgpu 和闭源实现 AMDGPU PRO。其中 AMD Catalyst 及 AMDGPU PRO 不被 Arch Linux 官方所支持（未收录于官方软件仓库）。 * xf86-video-amdgpu 支持 GCN 1、GCN 2、GCN 3、GCN 4 及更新架构的显卡。 * AMDGPU PRO 支持 GCN 3、GCN 4 及更新架构的显卡。 * xf86-video-ati 支持 X1000 及更早的显卡、TeraScale 1、TeraScale 2、TeraScale 3、GCN 1、GCN 2 架构的显卡。 * AMD Catalyst 支持 TeraScale 2、TeraScale 3、GCN 1、GCN 2、GCN 3 架构的显卡。 * AMD Catalyst Legacy 支持 TeraScale 1 架构的显卡。 中文字体 本文推荐思源黑体，可通过以下命令安装。 # pacman -S adobe-source-han-sans-cn-fonts 安装桌面环境 安装桌面环境需要的基础包 （就是 xorg ） # pacman -S xorg 这时会让汝选择需要哪些软件包啦,其实大多数时候默认的就行…… 接下来挑一个喜欢的桌面环境包组装上咯~ GNOME , 想要 GNOME 全家桶的话带上 gnome-extras # pacman -S gnome KDE Plasma , 想要 KDE 全家桶的话用 kde-applications-meta 代替 。 kde-applications 会提示汝选择要安装哪些包。 以及一个显示管理器， KDE 和 sddm 一起使用最好。 # pacman -S plasma sddm kde-applications 或者只安装 kdebase 组，包含了一些基本组件（例如文件管理器和终端模拟器）。 # pacman -S plasma sddm kdebase 安装中文输入法 # 推荐阅读 Arch 用户软件仓库) AUR 助手工具) 收尾工作 激活需要的服务，例如一个显示管理器，在例如 gdm ： # systemctl enable gdm 当然还有 NetworkManager： # systemctl enable NetworkManager 设置用户级别的 locale 用 su 切换到刚建立的用户，然后编辑 ~/.config/locale.conf 修改自己的 Locale ，例如： LANG=zh_CN.UTF-8 LC_CTYPE=\"zh_CN.UTF-8\" LC_NUMERIC=\"zh_CN.UTF-8\" LC_TIME=\"zh_CN.UTF-8\" LC_COLLATE=\"zh_CN.UTF-8\" LC_MONETARY=\"zh_CN.UTF-8\" LC_MESSAGES=\"zh_CN.UTF-8\" LC_PAPER=\"zh_CN.UTF-8\" LC_NAME=\"zh_CN.UTF-8\" LC_ADDRESS=\"zh_CN.UTF-8\" LC_TELEPHONE=\"zh_CN.UTF-8\" LC_MEASUREMENT=\"zh_CN.UTF-8\" LC_IDENTIFICATION=\"zh_CN.UTF-8\" LC_ALL= Pacman 命令详解 ## Pacman 命令详解 # Pacman 是一个命令行工具，这意味着当你执行下面的命令时，必须在终端或控制台中进行。 # 1、更新系统 # 在 Arch Linux 中，使用一条命令即可对整个系统进行更新： pacman -Syu # 如果你已经使用 pacman -Sy 将本地的包数据库与远程的仓库进行了同步，也可以只执行： pacman -Su # 2、安装包 pacman -S # 包名 例如，执行 pacman -S firefox 将安装 Firefox。你也可以同时安装多个包，只需以空格分隔包名即可。 pacman -Sy # 包名 与上面命令不同的是，该命令将在同步包数据库后再执行安装。 pacman -Sv # 包名 在显示一些操作信息后执行安装。 pacman -U # 安装本地包，其扩展名为 pkg.tar.gz pacman -U http://www.example.com/repo/example.pkg.tar.xz # 安装一个远程包（不在 pacman 配置的源里面） # 3、删除包 pacman -R # 该命令将只删除包，不包含该包的依赖。 pacman -Rs # 在删除包的同时，也将删除其依赖。 pacman -Rd # 在删除包时不检查依赖。 pacman -Rsc # 在删除包的同时，删除所有依赖这个软件包的程序 # 4、搜索包 pacman -Ss # 关键字 这将搜索含关键字的包。 pacman -Qs # 关键字 搜索已安装的包。 pacman -Qi # 查看有关包的信息。 pacman -Ql # 列出该包的文件。 # 5、其他用法 pacman -Sw # 只下载包，不安装。 pacman -Sc Pacman # 下载的包文件位于 /var/cache/pacman/pkg/ 目录。该命令将清理未安装的包文件。 pacman -Scc # 清理所有的缓存文件。 # 关于 Pacman 更加详细的用法，可以阅读 Pacman 的手册页 AUR 包手动安装 "},"System/Windows/":{"url":"System/Windows/","title":"Windows","keywords":"","body":"Windows termail命令 "},"System/Windows/termail.html":{"url":"System/Windows/termail.html","title":"termail 命令","keywords":"","body":"windows 命令 软链接文件夹 mklink /D node_modules \"D:\\git-hub\\conffront\\node_modules\" # 将当前 `D:\\git-hub\\conffront\\` 下的 node_modules 文件夹映射到 pwd 的 node_modules # /D 创建目录符号链接而不是文件符号链接（默认为文件符号链接） "}}